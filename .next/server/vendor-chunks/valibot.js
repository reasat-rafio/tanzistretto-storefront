"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/valibot";
exports.ids = ["vendor-chunks/valibot"];
exports.modules = {

/***/ "(ssr)/./node_modules/valibot/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/valibot/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BIC_REGEX: () => (/* binding */ BIC_REGEX),\n/* harmony export */   BrandSymbol: () => (/* binding */ BrandSymbol),\n/* harmony export */   CUID2_REGEX: () => (/* binding */ CUID2_REGEX),\n/* harmony export */   DECIMAL_REGEX: () => (/* binding */ DECIMAL_REGEX),\n/* harmony export */   EMAIL_REGEX: () => (/* binding */ EMAIL_REGEX),\n/* harmony export */   EMOJI_REGEX: () => (/* binding */ EMOJI_REGEX),\n/* harmony export */   HEXADECIMAL_REGEX: () => (/* binding */ HEXADECIMAL_REGEX),\n/* harmony export */   HEX_COLOR_REGEX: () => (/* binding */ HEX_COLOR_REGEX),\n/* harmony export */   IMEI_REGEX: () => (/* binding */ IMEI_REGEX),\n/* harmony export */   IPV4_REGEX: () => (/* binding */ IPV4_REGEX),\n/* harmony export */   IPV6_REGEX: () => (/* binding */ IPV6_REGEX),\n/* harmony export */   ISO_DATE_REGEX: () => (/* binding */ ISO_DATE_REGEX),\n/* harmony export */   ISO_DATE_TIME_REGEX: () => (/* binding */ ISO_DATE_TIME_REGEX),\n/* harmony export */   ISO_TIMESTAMP_REGEX: () => (/* binding */ ISO_TIMESTAMP_REGEX),\n/* harmony export */   ISO_TIME_REGEX: () => (/* binding */ ISO_TIME_REGEX),\n/* harmony export */   ISO_TIME_SECOND_REGEX: () => (/* binding */ ISO_TIME_SECOND_REGEX),\n/* harmony export */   ISO_WEEK_REGEX: () => (/* binding */ ISO_WEEK_REGEX),\n/* harmony export */   MAC48_REGEX: () => (/* binding */ MAC48_REGEX),\n/* harmony export */   MAC64_REGEX: () => (/* binding */ MAC64_REGEX),\n/* harmony export */   OCTAL_REGEX: () => (/* binding */ OCTAL_REGEX),\n/* harmony export */   ULID_REGEX: () => (/* binding */ ULID_REGEX),\n/* harmony export */   UUID_REGEX: () => (/* binding */ UUID_REGEX),\n/* harmony export */   ValiError: () => (/* binding */ ValiError),\n/* harmony export */   actionIssue: () => (/* binding */ actionIssue),\n/* harmony export */   actionOutput: () => (/* binding */ actionOutput),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   anyAsync: () => (/* binding */ anyAsync),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   arrayAsync: () => (/* binding */ arrayAsync),\n/* harmony export */   bic: () => (/* binding */ bic),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   bigintAsync: () => (/* binding */ bigintAsync),\n/* harmony export */   blob: () => (/* binding */ blob),\n/* harmony export */   blobAsync: () => (/* binding */ blobAsync),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   booleanAsync: () => (/* binding */ booleanAsync),\n/* harmony export */   brand: () => (/* binding */ brand),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   coerceAsync: () => (/* binding */ coerceAsync),\n/* harmony export */   creditCard: () => (/* binding */ creditCard),\n/* harmony export */   cuid2: () => (/* binding */ cuid2),\n/* harmony export */   custom: () => (/* binding */ custom),\n/* harmony export */   customAsync: () => (/* binding */ customAsync),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   dateAsync: () => (/* binding */ dateAsync),\n/* harmony export */   decimal: () => (/* binding */ decimal),\n/* harmony export */   defaultArgs: () => (/* binding */ defaultArgs),\n/* harmony export */   deleteGlobalConfig: () => (/* binding */ deleteGlobalConfig),\n/* harmony export */   deleteGlobalMessage: () => (/* binding */ deleteGlobalMessage),\n/* harmony export */   deleteSchemaMessage: () => (/* binding */ deleteSchemaMessage),\n/* harmony export */   deleteSpecificMessage: () => (/* binding */ deleteSpecificMessage),\n/* harmony export */   email: () => (/* binding */ email),\n/* harmony export */   emoji: () => (/* binding */ emoji),\n/* harmony export */   endsWith: () => (/* binding */ endsWith),\n/* harmony export */   enumAsync: () => (/* binding */ enumAsync),\n/* harmony export */   enum_: () => (/* binding */ enum_),\n/* harmony export */   every: () => (/* binding */ every),\n/* harmony export */   excludes: () => (/* binding */ excludes),\n/* harmony export */   fallback: () => (/* binding */ fallback),\n/* harmony export */   fallbackAsync: () => (/* binding */ fallbackAsync),\n/* harmony export */   finite: () => (/* binding */ finite),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   forward: () => (/* binding */ forward),\n/* harmony export */   forwardAsync: () => (/* binding */ forwardAsync),\n/* harmony export */   getDefault: () => (/* binding */ getDefault),\n/* harmony export */   getDefaultAsync: () => (/* binding */ getDefaultAsync),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getDefaultsAsync: () => (/* binding */ getDefaultsAsync),\n/* harmony export */   getFallback: () => (/* binding */ getFallback),\n/* harmony export */   getFallbackAsync: () => (/* binding */ getFallbackAsync),\n/* harmony export */   getFallbacks: () => (/* binding */ getFallbacks),\n/* harmony export */   getFallbacksAsync: () => (/* binding */ getFallbacksAsync),\n/* harmony export */   getGlobalConfig: () => (/* binding */ getGlobalConfig),\n/* harmony export */   getGlobalMessage: () => (/* binding */ getGlobalMessage),\n/* harmony export */   getSchemaMessage: () => (/* binding */ getSchemaMessage),\n/* harmony export */   getSpecificMessage: () => (/* binding */ getSpecificMessage),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   hexColor: () => (/* binding */ hexColor),\n/* harmony export */   hexadecimal: () => (/* binding */ hexadecimal),\n/* harmony export */   i18n: () => (/* binding */ i18n),\n/* harmony export */   imei: () => (/* binding */ imei),\n/* harmony export */   includes: () => (/* binding */ includes),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   instanceAsync: () => (/* binding */ instanceAsync),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersect: () => (/* binding */ intersect),\n/* harmony export */   intersectAsync: () => (/* binding */ intersectAsync),\n/* harmony export */   ip: () => (/* binding */ ip),\n/* harmony export */   ipv4: () => (/* binding */ ipv4),\n/* harmony export */   ipv6: () => (/* binding */ ipv6),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   isLuhnAlgo: () => (/* binding */ isLuhnAlgo),\n/* harmony export */   isOfType: () => (/* binding */ isOfType),\n/* harmony export */   isoDate: () => (/* binding */ isoDate),\n/* harmony export */   isoDateTime: () => (/* binding */ isoDateTime),\n/* harmony export */   isoTime: () => (/* binding */ isoTime),\n/* harmony export */   isoTimeSecond: () => (/* binding */ isoTimeSecond),\n/* harmony export */   isoTimestamp: () => (/* binding */ isoTimestamp),\n/* harmony export */   isoWeek: () => (/* binding */ isoWeek),\n/* harmony export */   keyof: () => (/* binding */ keyof),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   lazyAsync: () => (/* binding */ lazyAsync),\n/* harmony export */   length: () => (/* binding */ length),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   literalAsync: () => (/* binding */ literalAsync),\n/* harmony export */   mac: () => (/* binding */ mac),\n/* harmony export */   mac48: () => (/* binding */ mac48),\n/* harmony export */   mac64: () => (/* binding */ mac64),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapAsync: () => (/* binding */ mapAsync),\n/* harmony export */   maxBytes: () => (/* binding */ maxBytes),\n/* harmony export */   maxLength: () => (/* binding */ maxLength),\n/* harmony export */   maxSize: () => (/* binding */ maxSize),\n/* harmony export */   maxValue: () => (/* binding */ maxValue),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   mergeAsync: () => (/* binding */ mergeAsync),\n/* harmony export */   mimeType: () => (/* binding */ mimeType),\n/* harmony export */   minBytes: () => (/* binding */ minBytes),\n/* harmony export */   minLength: () => (/* binding */ minLength),\n/* harmony export */   minSize: () => (/* binding */ minSize),\n/* harmony export */   minValue: () => (/* binding */ minValue),\n/* harmony export */   multipleOf: () => (/* binding */ multipleOf),\n/* harmony export */   nan: () => (/* binding */ nan),\n/* harmony export */   nanAsync: () => (/* binding */ nanAsync),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   neverAsync: () => (/* binding */ neverAsync),\n/* harmony export */   nonNullable: () => (/* binding */ nonNullable),\n/* harmony export */   nonNullableAsync: () => (/* binding */ nonNullableAsync),\n/* harmony export */   nonNullish: () => (/* binding */ nonNullish),\n/* harmony export */   nonNullishAsync: () => (/* binding */ nonNullishAsync),\n/* harmony export */   nonOptional: () => (/* binding */ nonOptional),\n/* harmony export */   nonOptionalAsync: () => (/* binding */ nonOptionalAsync),\n/* harmony export */   notBytes: () => (/* binding */ notBytes),\n/* harmony export */   notLength: () => (/* binding */ notLength),\n/* harmony export */   notSize: () => (/* binding */ notSize),\n/* harmony export */   notValue: () => (/* binding */ notValue),\n/* harmony export */   nullAsync: () => (/* binding */ nullAsync),\n/* harmony export */   null_: () => (/* binding */ null_),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   nullableAsync: () => (/* binding */ nullableAsync),\n/* harmony export */   nullish: () => (/* binding */ nullish),\n/* harmony export */   nullishAsync: () => (/* binding */ nullishAsync),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   numberAsync: () => (/* binding */ numberAsync),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   objectAsync: () => (/* binding */ objectAsync),\n/* harmony export */   octal: () => (/* binding */ octal),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   omitAsync: () => (/* binding */ omitAsync),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   optionalAsync: () => (/* binding */ optionalAsync),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseAsync: () => (/* binding */ parseAsync),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   partialAsync: () => (/* binding */ partialAsync),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   pickAsync: () => (/* binding */ pickAsync),\n/* harmony export */   picklist: () => (/* binding */ picklist),\n/* harmony export */   picklistAsync: () => (/* binding */ picklistAsync),\n/* harmony export */   pipeResult: () => (/* binding */ pipeResult),\n/* harmony export */   pipeResultAsync: () => (/* binding */ pipeResultAsync),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   recordAsync: () => (/* binding */ recordAsync),\n/* harmony export */   regex: () => (/* binding */ regex),\n/* harmony export */   required: () => (/* binding */ required),\n/* harmony export */   requiredAsync: () => (/* binding */ requiredAsync),\n/* harmony export */   restAndDefaultArgs: () => (/* binding */ restAndDefaultArgs),\n/* harmony export */   safeInteger: () => (/* binding */ safeInteger),\n/* harmony export */   safeParse: () => (/* binding */ safeParse),\n/* harmony export */   safeParseAsync: () => (/* binding */ safeParseAsync),\n/* harmony export */   schemaIssue: () => (/* binding */ schemaIssue),\n/* harmony export */   schemaResult: () => (/* binding */ schemaResult),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setAsync: () => (/* binding */ setAsync),\n/* harmony export */   setGlobalConfig: () => (/* binding */ setGlobalConfig),\n/* harmony export */   setGlobalMessage: () => (/* binding */ setGlobalMessage),\n/* harmony export */   setSchemaMessage: () => (/* binding */ setSchemaMessage),\n/* harmony export */   setSpecificMessage: () => (/* binding */ setSpecificMessage),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   some: () => (/* binding */ some),\n/* harmony export */   special: () => (/* binding */ special),\n/* harmony export */   specialAsync: () => (/* binding */ specialAsync),\n/* harmony export */   startsWith: () => (/* binding */ startsWith),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   stringAsync: () => (/* binding */ stringAsync),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   symbol: () => (/* binding */ symbol),\n/* harmony export */   symbolAsync: () => (/* binding */ symbolAsync),\n/* harmony export */   toCustom: () => (/* binding */ toCustom),\n/* harmony export */   toCustomAsync: () => (/* binding */ toCustomAsync),\n/* harmony export */   toLowerCase: () => (/* binding */ toLowerCase),\n/* harmony export */   toMaxValue: () => (/* binding */ toMaxValue),\n/* harmony export */   toMinValue: () => (/* binding */ toMinValue),\n/* harmony export */   toTrimmed: () => (/* binding */ toTrimmed),\n/* harmony export */   toTrimmedEnd: () => (/* binding */ toTrimmedEnd),\n/* harmony export */   toTrimmedStart: () => (/* binding */ toTrimmedStart),\n/* harmony export */   toUpperCase: () => (/* binding */ toUpperCase),\n/* harmony export */   transform: () => (/* binding */ transform),\n/* harmony export */   transformAsync: () => (/* binding */ transformAsync),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   tupleAsync: () => (/* binding */ tupleAsync),\n/* harmony export */   ulid: () => (/* binding */ ulid),\n/* harmony export */   undefinedAsync: () => (/* binding */ undefinedAsync),\n/* harmony export */   undefined_: () => (/* binding */ undefined_),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unionAsync: () => (/* binding */ unionAsync),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   unknownAsync: () => (/* binding */ unknownAsync),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   url: () => (/* binding */ url),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   value: () => (/* binding */ value),\n/* harmony export */   variant: () => (/* binding */ variant),\n/* harmony export */   variantAsync: () => (/* binding */ variantAsync),\n/* harmony export */   voidAsync: () => (/* binding */ voidAsync),\n/* harmony export */   void_: () => (/* binding */ void_)\n/* harmony export */ });\n// src/error/flatten/flatten.ts\nfunction flatten(arg1) {\n  return (Array.isArray(arg1) ? arg1 : arg1.issues).reduce(\n    (flatErrors, issue) => {\n      if (issue.path) {\n        if (issue.path.every(\n          ({ key }) => typeof key === \"string\" || typeof key === \"number\"\n        )) {\n          const path = issue.path.map(({ key }) => key).join(\".\");\n          if (flatErrors.nested[path]) {\n            flatErrors.nested[path].push(issue.message);\n          } else {\n            flatErrors.nested[path] = [issue.message];\n          }\n        }\n      } else {\n        if (flatErrors.root) {\n          flatErrors.root.push(issue.message);\n        } else {\n          flatErrors.root = [issue.message];\n        }\n      }\n      return flatErrors;\n    },\n    { nested: {} }\n  );\n}\n\n// src/error/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/methods/brand/brand.ts\nvar BrandSymbol = Symbol(\"brand\");\nfunction brand(schema, name) {\n  return schema;\n}\n\n// src/methods/coerce/coerce.ts\nfunction coerce(schema, action) {\n  return {\n    ...schema,\n    _parse(input, config) {\n      return schema._parse(action(input), config);\n    }\n  };\n}\n\n// src/methods/coerce/coerceAsync.ts\nfunction coerceAsync(schema, action) {\n  return {\n    ...schema,\n    async _parse(input, config) {\n      return schema._parse(await action(input), config);\n    }\n  };\n}\n\n// src/utils/actionIssue/actionIssue.ts\nfunction actionIssue(context, reference, input, label, received) {\n  return {\n    issues: [{ context, reference, input, label, received }]\n  };\n}\n\n// src/utils/actionOutput/actionOutput.ts\nfunction actionOutput(output) {\n  return { output };\n}\n\n// src/utils/defaultArgs/defaultArgs.ts\nfunction defaultArgs(arg1, arg2) {\n  return Array.isArray(arg1) ? [void 0, arg1] : [arg1, arg2];\n}\n\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config) {\n  store = { ...store, ...config };\n}\nfunction getGlobalConfig(config) {\n  return {\n    lang: config?.lang ?? store?.lang,\n    message: config?.message,\n    abortEarly: config?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config?.abortPipeEarly ?? store?.abortPipeEarly,\n    skipPipe: config?.skipPipe ?? store?.skipPipe\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2)\n    store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3)\n    store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4)\n    store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference))\n    store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/i18n/i18n.ts\nfunction i18n(schema, context, reference, config, issue) {\n  const message = context.message ?? getSpecificMessage(reference, issue.lang) ?? (schema ? getSchemaMessage(issue.lang) : null) ?? config?.message ?? getGlobalMessage(issue.lang) ?? issue.message;\n  return typeof message === \"function\" ? message(issue) : message;\n}\n\n// src/utils/isLuhnAlgo/isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/isOfType/isOfType.ts\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/schemaResult/schemaResult.ts\nfunction schemaResult(typed, output, issues) {\n  return { typed, output, issues };\n}\n\n// src/utils/stringify/stringify.ts\nfunction stringify(input) {\n  let type = typeof input;\n  if (type === \"object\") {\n    type = input ? Object.getPrototypeOf(input).constructor.name : \"null\";\n  }\n  return type === \"string\" ? `\"${input}\"` : type === \"number\" || type === \"bigint\" || type === \"boolean\" ? `${input}` : type;\n}\n\n// src/utils/pipeResult/utils/pipeIssue/pipeIssue.ts\nfunction pipeIssue(context, config, issue) {\n  const received = issue.received ?? stringify(issue.input);\n  const schemaIssue2 = {\n    reason: context.type,\n    context: issue.context.type,\n    expected: issue.context.expects,\n    received,\n    message: `Invalid ${issue.label}: ${issue.context.expects ? `Expected ${issue.context.expects} but r` : \"R\"}eceived ${received}`,\n    input: issue.input,\n    requirement: issue.context.requirement,\n    path: issue.path,\n    lang: config?.lang,\n    abortEarly: config?.abortEarly,\n    abortPipeEarly: config?.abortPipeEarly,\n    skipPipe: config?.skipPipe\n  };\n  schemaIssue2.message = i18n(\n    false,\n    issue.context,\n    issue.reference,\n    config,\n    schemaIssue2\n  );\n  return schemaIssue2;\n}\n\n// src/utils/pipeResult/pipeResult.ts\nfunction pipeResult(context, input, config, issues) {\n  if (context.pipe && !config?.skipPipe) {\n    for (const action of context.pipe) {\n      const result = action._parse(input);\n      if (result.issues) {\n        for (const actionIssue2 of result.issues) {\n          const schemaIssue2 = pipeIssue(context, config, actionIssue2);\n          issues ? issues.push(schemaIssue2) : issues = [schemaIssue2];\n        }\n        if (config?.abortEarly || config?.abortPipeEarly) {\n          break;\n        }\n      } else {\n        input = result.output;\n      }\n    }\n  }\n  return schemaResult(true, input, issues);\n}\n\n// src/utils/pipeResult/pipeResultAsync.ts\nasync function pipeResultAsync(context, input, config, issues) {\n  if (context.pipe && !config?.skipPipe) {\n    for (const action of context.pipe) {\n      const result = await action._parse(input);\n      if (result.issues) {\n        for (const actionIssue2 of result.issues) {\n          const schemaIssue2 = pipeIssue(context, config, actionIssue2);\n          issues ? issues.push(schemaIssue2) : issues = [schemaIssue2];\n        }\n        if (config?.abortEarly || config?.abortPipeEarly) {\n          break;\n        }\n      } else {\n        input = result.output;\n      }\n    }\n  }\n  return schemaResult(true, input, issues);\n}\n\n// src/utils/restAndDefaultArgs/restAndDefaultArgs.ts\nfunction restAndDefaultArgs(arg1, arg2, arg3) {\n  if (!arg1 || typeof arg1 === \"object\" && !Array.isArray(arg1)) {\n    const [error2, pipe2] = defaultArgs(arg2, arg3);\n    return [arg1, error2, pipe2];\n  }\n  const [error, pipe] = defaultArgs(\n    arg1,\n    arg2\n  );\n  return [void 0, error, pipe];\n}\n\n// src/utils/schemaIssue/schemaIssue.ts\nfunction schemaIssue(context, reference, input, config, other) {\n  const received = stringify(input);\n  const expected = other?.expected ?? context.expects;\n  const issue = {\n    reason: other?.reason ?? \"type\",\n    context: context.type,\n    expected,\n    received,\n    message: `Invalid type: Expected ${expected} but received ${received}`,\n    input,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config?.lang,\n    abortEarly: config?.abortEarly,\n    abortPipeEarly: config?.abortPipeEarly,\n    skipPipe: config?.skipPipe\n  };\n  issue.message = i18n(true, context, reference, config, issue);\n  return { typed: false, output: input, issues: [issue] };\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, info) {\n  return typeof schema.fallback === \"function\" ? schema.fallback(info) : schema.fallback;\n}\n\n// src/methods/getFallback/getFallbackAsync.ts\nasync function getFallbackAsync(schema, info) {\n  return typeof schema.fallback === \"function\" ? await schema.fallback(info) : schema.fallback;\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    _parse(input, config) {\n      const result = schema._parse(input, config);\n      return result.issues ? schemaResult(\n        true,\n        getFallback(this, { input, issues: result.issues })\n      ) : result;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async _parse(input, config) {\n      const result = await schema._parse(input, config);\n      return result.issues ? schemaResult(\n        true,\n        await getFallbackAsync(this, { input, issues: result.issues })\n      ) : result;\n    }\n  };\n}\n\n// src/methods/forward/forward.ts\nfunction forward(validation, pathList) {\n  return {\n    ...validation,\n    _parse(input) {\n      const result = validation._parse(input);\n      if (result.issues) {\n        for (const issue of result.issues) {\n          let pathInput = input;\n          for (const key of pathList) {\n            const pathValue = pathInput[key];\n            issue.input = pathValue;\n            const pathItem = {\n              type: \"unknown\",\n              origin: \"value\",\n              input: pathInput,\n              key,\n              value: pathValue\n            };\n            issue.path ? issue.path.push(pathItem) : issue.path = [pathItem];\n            if (!pathValue) {\n              break;\n            }\n            pathInput = pathValue;\n          }\n        }\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\nfunction forwardAsync(validation, pathList) {\n  return {\n    ...validation,\n    async _parse(input) {\n      const result = await validation._parse(input);\n      if (result.issues) {\n        for (const issue of result.issues) {\n          let pathInput = input;\n          for (const key of pathList) {\n            const pathValue = pathInput[key];\n            issue.input = pathValue;\n            const pathItem = {\n              type: \"unknown\",\n              origin: \"value\",\n              input: pathInput,\n              key,\n              value: pathValue\n            };\n            issue.path ? issue.path.push(pathItem) : issue.path = [pathItem];\n            if (!pathValue) {\n              break;\n            }\n            pathInput = pathValue;\n          }\n        }\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema) {\n  return typeof schema.default === \"function\" ? schema.default() : schema.default;\n}\n\n// src/methods/getDefault/getDefaultAsync.ts\nasync function getDefaultAsync(schema) {\n  return typeof schema.default === \"function\" ? await schema.default() : schema.default;\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  if (schema.default !== void 0) {\n    return getDefault(schema);\n  }\n  if (isOfType(\"object\", schema)) {\n    return Object.fromEntries(\n      Object.entries(schema.entries).map(([key, value2]) => [\n        key,\n        getDefaults(value2)\n      ])\n    );\n  }\n  if (isOfType(\"tuple\", schema)) {\n    return schema.items.map(getDefaults);\n  }\n  return void 0;\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  if (schema.default !== void 0) {\n    return getDefaultAsync(schema);\n  }\n  if (isOfType(\"object\", schema)) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (isOfType(\"tuple\", schema)) {\n    return Promise.all(\n      schema.items.map(getDefaultsAsync)\n    );\n  }\n  return void 0;\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  if (schema.fallback !== void 0) {\n    return getFallback(schema);\n  }\n  if (isOfType(\"object\", schema)) {\n    return Object.fromEntries(\n      Object.entries(schema.entries).map(([key, value2]) => [\n        key,\n        getFallbacks(value2)\n      ])\n    );\n  }\n  if (isOfType(\"tuple\", schema)) {\n    return schema.items.map(getFallbacks);\n  }\n  return void 0;\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  if (schema.fallback !== void 0) {\n    return getFallbackAsync(schema);\n  }\n  if (isOfType(\"object\", schema)) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (isOfType(\"tuple\", schema)) {\n    return Promise.all(\n      schema.items.map(getFallbacksAsync)\n    );\n  }\n  return void 0;\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input, config) {\n  return !schema._parse(input, {\n    abortEarly: true,\n    skipPipe: getGlobalConfig(config)?.skipPipe\n  }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any(pipe) {\n  return {\n    type: \"any\",\n    expects: \"any\",\n    async: false,\n    pipe,\n    _parse(input, config) {\n      return pipeResult(this, input, config);\n    }\n  };\n}\n\n// src/schemas/any/anyAsync.ts\nfunction anyAsync(pipe) {\n  return {\n    type: \"any\",\n    expects: \"any\",\n    async: true,\n    pipe,\n    async _parse(input, config) {\n      return pipeResultAsync(this, input, config);\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"array\",\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (Array.isArray(input)) {\n        let typed = true;\n        let issues;\n        const output = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const result = this.item._parse(value2, config);\n          if (result.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!result.typed) {\n            typed = false;\n          }\n          output.push(result.output);\n        }\n        if (typed) {\n          return pipeResult(this, output, config, issues);\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, array, input, config);\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"array\",\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (Array.isArray(input)) {\n        let typed = true;\n        let issues;\n        const output = [];\n        await Promise.all(\n          input.map(async (value2, key) => {\n            if (!(config?.abortEarly && issues)) {\n              const result = await this.item._parse(value2, config);\n              if (!(config?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"array\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (config?.abortEarly) {\n                    typed = false;\n                    throw null;\n                  }\n                }\n                if (!result.typed) {\n                  typed = false;\n                }\n                output[key] = result.output;\n              }\n            }\n          })\n        ).catch(() => null);\n        if (typed) {\n          return pipeResultAsync(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, arrayAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"bigint\",\n    expects: \"bigint\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (typeof input === \"bigint\") {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, bigint, input, config);\n    }\n  };\n}\n\n// src/schemas/bigint/bigintAsync.ts\nfunction bigintAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"bigint\",\n    expects: \"bigint\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (typeof input === \"bigint\") {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, bigintAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"blob\",\n    expects: \"Blob\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input instanceof Blob) {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, blob, input, config);\n    }\n  };\n}\n\n// src/schemas/blob/blobAsync.ts\nfunction blobAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"blob\",\n    expects: \"Blob\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input instanceof Blob) {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, blobAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"boolean\",\n    expects: \"boolean\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (typeof input === \"boolean\") {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, boolean, input, config);\n    }\n  };\n}\n\n// src/schemas/boolean/booleanAsync.ts\nfunction booleanAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"boolean\",\n    expects: \"boolean\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (typeof input === \"boolean\") {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, booleanAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"date\",\n    expects: \"Date\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input instanceof Date && !isNaN(input.getTime())) {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, date, input, config);\n    }\n  };\n}\n\n// src/schemas/date/dateAsync.ts\nfunction dateAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"date\",\n    expects: \"Date\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input instanceof Date && !isNaN(input.getTime())) {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, dateAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum__, message) {\n  const values = Object.values(enum__);\n  return {\n    type: \"enum\",\n    expects: values.map(stringify).join(\" | \"),\n    async: false,\n    enum: enum__,\n    message,\n    _parse(input, config) {\n      if (values.includes(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, enum_, input, config);\n    }\n  };\n}\n\n// src/schemas/enum/enumAsync.ts\nfunction enumAsync(enum_2, message) {\n  const values = Object.values(enum_2);\n  return {\n    type: \"enum\",\n    expects: values.map(stringify).join(\" | \"),\n    async: true,\n    enum: enum_2,\n    message,\n    async _parse(input, config) {\n      if (values.includes(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, enumAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\nfunction instance(class_, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"instance\",\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input instanceof this.class) {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, instance, input, config);\n    }\n  };\n}\n\n// src/schemas/instance/instanceAsync.ts\nfunction instanceAsync(class_, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"instance\",\n    expects: class_.name,\n    async: true,\n    class: class_,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input instanceof this.class) {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, instanceAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/intersect/utils/mergeOutputs/mergeOutputs.ts\nfunction mergeOutputs(output1, output2) {\n  if (typeof output1 === typeof output2) {\n    if (output1 === output2 || output1 instanceof Date && output2 instanceof Date && +output1 === +output2) {\n      return { output: output1 };\n    }\n    if (Array.isArray(output1) && Array.isArray(output2)) {\n      if (output1.length === output2.length) {\n        const array2 = [];\n        for (let index = 0; index < output1.length; index++) {\n          const result = mergeOutputs(output1[index], output2[index]);\n          if (result.invalid) {\n            return result;\n          }\n          array2.push(result.output);\n        }\n        return { output: array2 };\n      }\n      return { invalid: true };\n    }\n    if (output1 && output2 && output1.constructor === Object && output2.constructor === Object) {\n      const object2 = { ...output1, ...output2 };\n      for (const key in output1) {\n        if (key in output2) {\n          const result = mergeOutputs(output1[key], output2[key]);\n          if (result.invalid) {\n            return result;\n          }\n          object2[key] = result.output;\n        }\n      }\n      return { output: object2 };\n    }\n  }\n  return { invalid: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"intersect\",\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \"),\n    async: false,\n    options,\n    message,\n    pipe,\n    _parse(input, config) {\n      let typed = true;\n      let issues;\n      let output;\n      const outputs = [];\n      for (const schema of this.options) {\n        const result = schema._parse(input, config);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n          if (config?.abortEarly) {\n            typed = false;\n            break;\n          }\n        }\n        if (!result.typed) {\n          typed = false;\n        }\n        outputs.push(result.output);\n      }\n      if (typed) {\n        output = outputs[0];\n        for (let index = 1; index < outputs.length; index++) {\n          const result = mergeOutputs(output, outputs[index]);\n          if (result.invalid) {\n            return schemaIssue(this, intersect, input, config);\n          }\n          output = result.output;\n        }\n        return pipeResult(this, output, config, issues);\n      }\n      return schemaResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\nfunction intersectAsync(options, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"intersect\",\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \"),\n    async: true,\n    options,\n    message,\n    pipe,\n    async _parse(input, config) {\n      let typed = true;\n      let issues;\n      let output;\n      const outputs = [];\n      await Promise.all(\n        this.options.map(async (schema) => {\n          if (!(config?.abortEarly && issues)) {\n            const result = await schema._parse(input, config);\n            if (!(config?.abortEarly && issues)) {\n              if (result.issues) {\n                if (issues) {\n                  for (const issue of result.issues) {\n                    issues.push(issue);\n                  }\n                } else {\n                  issues = result.issues;\n                }\n                if (config?.abortEarly) {\n                  typed = false;\n                  throw null;\n                }\n              }\n              if (!result.typed) {\n                typed = false;\n              }\n              outputs.push(result.output);\n            }\n          }\n        })\n      ).catch(() => null);\n      if (typed) {\n        output = outputs[0];\n        for (let index = 1; index < outputs.length; index++) {\n          const result = mergeOutputs(output, outputs[index]);\n          if (result.invalid) {\n            return schemaIssue(this, intersectAsync, input, config);\n          }\n          output = result.output;\n        }\n        return pipeResultAsync(this, output, config, issues);\n      }\n      return schemaResult(false, output, issues);\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\nfunction lazy(getter) {\n  return {\n    type: \"lazy\",\n    expects: \"unknown\",\n    async: false,\n    getter,\n    _parse(input, config) {\n      return this.getter(input)._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\nfunction lazyAsync(getter) {\n  return {\n    type: \"lazy\",\n    expects: \"unknown\",\n    async: true,\n    getter,\n    async _parse(input, config) {\n      return (await this.getter(input))._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\nfunction literal(literal_, message) {\n  return {\n    type: \"literal\",\n    expects: stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    _parse(input, config) {\n      if (input === this.literal) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, literal, input, config);\n    }\n  };\n}\n\n// src/schemas/literal/literalAsync.ts\nfunction literalAsync(literal2, message) {\n  return {\n    type: \"literal\",\n    expects: stringify(literal2),\n    async: true,\n    literal: literal2,\n    message,\n    async _parse(input, config) {\n      if (input === this.literal) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, literalAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, arg3, arg4) {\n  const [message, pipe] = defaultArgs(arg3, arg4);\n  return {\n    type: \"map\",\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input instanceof Map) {\n        let typed = true;\n        let issues;\n        const output = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input.entries()) {\n          let pathItem;\n          const keyResult = this.key._parse(inputKey, config);\n          if (keyResult.issues) {\n            pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyResult.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = keyResult.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          const valueResult = this.value._parse(inputValue, config);\n          if (valueResult.issues) {\n            pathItem = pathItem ?? {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueResult.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = valueResult.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!keyResult.typed || !valueResult.typed) {\n            typed = false;\n          }\n          output.set(keyResult.output, valueResult.output);\n        }\n        if (typed) {\n          return pipeResult(this, output, config, issues);\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, map, input, config);\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, arg3, arg4) {\n  const [message, pipe] = defaultArgs(arg3, arg4);\n  return {\n    type: \"map\",\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input instanceof Map) {\n        let typed = true;\n        let issues;\n        const output = /* @__PURE__ */ new Map();\n        await Promise.all(\n          Array.from(input.entries()).map(async ([inputKey, inputValue]) => {\n            let pathItem;\n            const [keyResult, valueResult] = await Promise.all(\n              [\n                { schema: this.key, value: inputKey, origin: \"key\" },\n                { schema: this.value, value: inputValue, origin: \"value\" }\n              ].map(async ({ schema, value: value3, origin }) => {\n                if (!(config?.abortEarly && issues)) {\n                  const result = await schema._parse(value3, config);\n                  if (!(config?.abortEarly && issues)) {\n                    if (result.issues) {\n                      pathItem = pathItem ?? {\n                        type: \"map\",\n                        origin,\n                        input,\n                        key: inputKey,\n                        value: inputValue\n                      };\n                      for (const issue of result.issues) {\n                        if (issue.path) {\n                          issue.path.unshift(pathItem);\n                        } else {\n                          issue.path = [pathItem];\n                        }\n                        issues?.push(issue);\n                      }\n                      if (!issues) {\n                        issues = result.issues;\n                      }\n                      if (config?.abortEarly) {\n                        throw null;\n                      }\n                    }\n                    return result;\n                  }\n                }\n              })\n            ).catch(() => []);\n            if (!keyResult?.typed || !valueResult?.typed) {\n              typed = false;\n            }\n            if (keyResult && valueResult) {\n              output.set(keyResult.output, valueResult.output);\n            }\n          })\n        );\n        if (typed) {\n          return pipeResultAsync(this, output, config, issues);\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, mapAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(message) {\n  return {\n    type: \"nan\",\n    expects: \"NaN\",\n    async: false,\n    message,\n    _parse(input, config) {\n      if (Number.isNaN(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, nan, input, config);\n    }\n  };\n}\n\n// src/schemas/nan/nanAsync.ts\nfunction nanAsync(message) {\n  return {\n    type: \"nan\",\n    expects: \"NaN\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      if (Number.isNaN(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, nanAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(message) {\n  return {\n    type: \"never\",\n    expects: \"never\",\n    async: false,\n    message,\n    _parse(input, config) {\n      return schemaIssue(this, never, input, config);\n    }\n  };\n}\n\n// src/schemas/never/neverAsync.ts\nfunction neverAsync(message) {\n  return {\n    type: \"never\",\n    expects: \"never\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      return schemaIssue(this, neverAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message) {\n  return {\n    type: \"non_nullable\",\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, config) {\n      if (input === null) {\n        return schemaIssue(this, nonNullable, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    type: \"non_nullable\",\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, config) {\n      if (input === null) {\n        return schemaIssue(this, nonNullableAsync, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message) {\n  return {\n    type: \"non_nullish\",\n    expects: \"!null & !undefined\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, config) {\n      if (input === null || input === void 0) {\n        return schemaIssue(this, nonNullish, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    type: \"non_nullish\",\n    expects: \"!null & !undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, config) {\n      if (input === null || input === void 0) {\n        return schemaIssue(this, nonNullishAsync, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message) {\n  return {\n    type: \"non_optional\",\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, config) {\n      if (input === void 0) {\n        return schemaIssue(this, nonOptional, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    type: \"non_optional\",\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, config) {\n      if (input === void 0) {\n        return schemaIssue(this, nonOptionalAsync, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, default_) {\n  return {\n    type: \"nullable\",\n    expects: `${wrapped.expects} | null`,\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, config) {\n      if (input === null) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, default_) {\n  return {\n    type: \"nullable\",\n    expects: `${wrapped.expects} | null`,\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, config) {\n      if (input === null) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, default_) {\n  return {\n    type: \"nullish\",\n    expects: `${wrapped.expects} | null | undefined`,\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, config) {\n      if (input === null || input === void 0) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, default_) {\n  return {\n    type: \"nullish\",\n    expects: `${wrapped.expects} | null | undefined`,\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, config) {\n      if (input === null || input === void 0) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(message) {\n  return {\n    type: \"null\",\n    expects: \"null\",\n    async: false,\n    message,\n    _parse(input, config) {\n      if (input === null) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, null_, input, config);\n    }\n  };\n}\n\n// src/schemas/null/nullAsync.ts\nfunction nullAsync(message) {\n  return {\n    type: \"null\",\n    expects: \"null\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      if (input === null) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, nullAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/number/number.ts\nfunction number(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"number\",\n    expects: \"number\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (typeof input === \"number\" && !isNaN(input)) {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, number, input, config);\n    }\n  };\n}\n\n// src/schemas/number/numberAsync.ts\nfunction numberAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"number\",\n    expects: \"number\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (typeof input === \"number\" && !isNaN(input)) {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, numberAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    type: \"object\",\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        cachedEntries = cachedEntries ?? Object.entries(this.entries);\n        let typed = true;\n        let issues;\n        const output = {};\n        for (const [key, schema] of cachedEntries) {\n          const value2 = input[key];\n          const result = schema._parse(value2, config);\n          if (result.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!result.typed) {\n            typed = false;\n          }\n          if (result.output !== void 0 || key in input) {\n            output[key] = result.output;\n          }\n        }\n        if (this.rest && !(config?.abortEarly && issues)) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              const result = this.rest._parse(value2, config);\n              if (result.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of result.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  issues?.push(issue);\n                }\n                if (!issues) {\n                  issues = result.issues;\n                }\n                if (config?.abortEarly) {\n                  typed = false;\n                  break;\n                }\n              }\n              if (!result.typed) {\n                typed = false;\n              }\n              output[key] = result.output;\n            }\n          }\n        }\n        if (typed) {\n          return pipeResult(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, object, input, config);\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    type: \"object\",\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        cachedEntries = cachedEntries ?? Object.entries(this.entries);\n        let typed = true;\n        let issues;\n        const output = {};\n        await Promise.all([\n          Promise.all(\n            cachedEntries.map(async ([key, schema]) => {\n              if (!(config?.abortEarly && issues)) {\n                const value2 = input[key];\n                const result = await schema._parse(value2, config);\n                if (!(config?.abortEarly && issues)) {\n                  if (result.issues) {\n                    const pathItem = {\n                      type: \"object\",\n                      origin: \"value\",\n                      input,\n                      key,\n                      value: value2\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (config?.abortEarly) {\n                      typed = false;\n                      throw null;\n                    }\n                  }\n                  if (!result.typed) {\n                    typed = false;\n                  }\n                  if (result.output !== void 0 || key in input) {\n                    output[key] = result.output;\n                  }\n                }\n              }\n            })\n          ),\n          this.rest && Promise.all(\n            Object.entries(input).map(async ([key, value2]) => {\n              if (!(config?.abortEarly && issues)) {\n                if (!(key in this.entries)) {\n                  const result = await this.rest._parse(value2, config);\n                  if (!(config?.abortEarly && issues)) {\n                    if (result.issues) {\n                      const pathItem = {\n                        type: \"object\",\n                        origin: \"value\",\n                        input,\n                        key,\n                        value: value2\n                      };\n                      for (const issue of result.issues) {\n                        if (issue.path) {\n                          issue.path.unshift(pathItem);\n                        } else {\n                          issue.path = [pathItem];\n                        }\n                        issues?.push(issue);\n                      }\n                      if (!issues) {\n                        issues = result.issues;\n                      }\n                      if (config?.abortEarly) {\n                        typed = false;\n                        throw null;\n                      }\n                    }\n                    if (!result.typed) {\n                      typed = false;\n                    }\n                    output[key] = result.output;\n                  }\n                }\n              }\n            })\n          )\n        ]).catch(() => null);\n        if (typed) {\n          return pipeResultAsync(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, objectAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, default_) {\n  return {\n    type: \"optional\",\n    expects: `${wrapped.expects} | undefined`,\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, config) {\n      if (input === void 0) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, default_) {\n  return {\n    type: \"optional\",\n    expects: `${wrapped.expects} | undefined`,\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, config) {\n      if (input === void 0) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message) {\n  return {\n    type: \"picklist\",\n    expects: options.map(stringify).join(\" | \"),\n    async: false,\n    options,\n    message,\n    _parse(input, config) {\n      if (this.options.includes(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, picklist, input, config);\n    }\n  };\n}\n\n// src/schemas/picklist/picklistAsync.ts\nfunction picklistAsync(options, message) {\n  return {\n    type: \"picklist\",\n    expects: options.map(stringify).join(\" | \"),\n    async: true,\n    options,\n    message,\n    async _parse(input, config) {\n      if (this.options.includes(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, picklistAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/string/string.ts\nfunction string(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"string\",\n    expects: \"string\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (typeof input === \"string\") {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, string, input, config);\n    }\n  };\n}\n\n// src/schemas/string/stringAsync.ts\nfunction stringAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"string\",\n    expects: \"string\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (typeof input === \"string\") {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, stringAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/record/utils/recordArgs/recordArgs.ts\nfunction recordArgs(arg1, arg2, arg3, arg4) {\n  if (typeof arg2 === \"object\" && !Array.isArray(arg2)) {\n    const [message2, pipe2] = defaultArgs(arg3, arg4);\n    return [arg1, arg2, message2, pipe2];\n  }\n  const [message, pipe] = defaultArgs(\n    arg2,\n    arg3\n  );\n  return [string(), arg1, message, pipe];\n}\n\n// src/schemas/record/values.ts\nvar BLOCKED_KEYS = [\"__proto__\", \"prototype\", \"constructor\"];\n\n// src/schemas/record/record.ts\nfunction record(arg1, arg2, arg3, arg4) {\n  const [key, value2, message, pipe] = recordArgs(arg1, arg2, arg3, arg4);\n  return {\n    type: \"record\",\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        let typed = true;\n        let issues;\n        const output = {};\n        for (const [inputKey, inputValue] of Object.entries(input)) {\n          if (!BLOCKED_KEYS.includes(inputKey)) {\n            let pathItem;\n            const keyResult = this.key._parse(inputKey, config);\n            if (keyResult.issues) {\n              pathItem = {\n                type: \"record\",\n                origin: \"key\",\n                input,\n                key: inputKey,\n                value: inputValue\n              };\n              for (const issue of keyResult.issues) {\n                issue.path = [pathItem];\n                issues?.push(issue);\n              }\n              if (!issues) {\n                issues = keyResult.issues;\n              }\n              if (config?.abortEarly) {\n                typed = false;\n                break;\n              }\n            }\n            const valueResult = this.value._parse(inputValue, config);\n            if (valueResult.issues) {\n              pathItem = pathItem ?? {\n                type: \"record\",\n                origin: \"value\",\n                input,\n                key: inputKey,\n                value: inputValue\n              };\n              for (const issue of valueResult.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                issues?.push(issue);\n              }\n              if (!issues) {\n                issues = valueResult.issues;\n              }\n              if (config?.abortEarly) {\n                typed = false;\n                break;\n              }\n            }\n            if (!keyResult.typed || !valueResult.typed) {\n              typed = false;\n            }\n            if (keyResult.typed) {\n              output[keyResult.output] = valueResult.output;\n            }\n          }\n        }\n        if (typed) {\n          return pipeResult(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, record, input, config);\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(arg1, arg2, arg3, arg4) {\n  const [key, value2, message, pipe] = recordArgs(arg1, arg2, arg3, arg4);\n  return {\n    type: \"record\",\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        let typed = true;\n        let issues;\n        const output = {};\n        await Promise.all(\n          // Note: `Object.entries(...)` converts each key to a string\n          Object.entries(input).map(async ([inputKey, inputValue]) => {\n            if (!BLOCKED_KEYS.includes(inputKey)) {\n              let pathItem;\n              const [keyResult, valueResult] = await Promise.all(\n                [\n                  { schema: this.key, value: inputKey, origin: \"key\" },\n                  { schema: this.value, value: inputValue, origin: \"value\" }\n                ].map(async ({ schema, value: value3, origin }) => {\n                  if (!(config?.abortEarly && issues)) {\n                    const result = await schema._parse(value3, config);\n                    if (!(config?.abortEarly && issues)) {\n                      if (result.issues) {\n                        pathItem = pathItem ?? {\n                          type: \"record\",\n                          origin,\n                          input,\n                          key: inputKey,\n                          value: inputValue\n                        };\n                        for (const issue of result.issues) {\n                          if (issue.path) {\n                            issue.path.unshift(pathItem);\n                          } else {\n                            issue.path = [pathItem];\n                          }\n                          issues?.push(issue);\n                        }\n                        if (!issues) {\n                          issues = result.issues;\n                        }\n                        if (config?.abortEarly) {\n                          throw null;\n                        }\n                      }\n                      return result;\n                    }\n                  }\n                })\n              ).catch(() => []);\n              if (!keyResult?.typed || !valueResult?.typed) {\n                typed = false;\n              }\n              if (keyResult?.typed && valueResult) {\n                output[keyResult.output] = valueResult.output;\n              }\n            }\n          })\n        );\n        if (typed) {\n          return pipeResultAsync(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, recordAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"set\",\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input instanceof Set) {\n        let key = 0;\n        let typed = true;\n        let issues;\n        const output = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const result = this.value._parse(inputValue, config);\n          if (result.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key,\n              value: inputValue\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!result.typed) {\n            typed = false;\n          }\n          output.add(result.output);\n          key++;\n        }\n        if (typed) {\n          return pipeResult(this, output, config, issues);\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, set, input, config);\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"set\",\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input instanceof Set) {\n        let typed = true;\n        let issues;\n        const output = /* @__PURE__ */ new Set();\n        await Promise.all(\n          Array.from(input.values()).map(async (inputValue, key) => {\n            if (!(config?.abortEarly && issues)) {\n              const result = await this.value._parse(inputValue, config);\n              if (!(config?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"set\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: inputValue\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (config?.abortEarly) {\n                    typed = false;\n                    throw null;\n                  }\n                }\n                if (!result.typed) {\n                  typed = false;\n                }\n                output.add(result.output);\n              }\n            }\n          })\n        ).catch(() => null);\n        if (typed) {\n          return pipeResultAsync(this, output, config, issues);\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, setAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/special/special.ts\nfunction special(check, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"special\",\n    expects: \"unknown\",\n    async: false,\n    check,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (this.check(input)) {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, special, input, config);\n    }\n  };\n}\n\n// src/schemas/special/specialAsync.ts\nfunction specialAsync(check, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"special\",\n    expects: \"unknown\",\n    async: true,\n    check,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (await this.check(input)) {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, specialAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(message) {\n  return {\n    type: \"symbol\",\n    expects: \"symbol\",\n    async: false,\n    message,\n    _parse(input, config) {\n      if (typeof input === \"symbol\") {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, symbol, input, config);\n    }\n  };\n}\n\n// src/schemas/symbol/symbolAsync.ts\nfunction symbolAsync(message) {\n  return {\n    type: \"symbol\",\n    expects: \"symbol\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      if (typeof input === \"symbol\") {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, symbolAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    type: \"tuple\",\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (Array.isArray(input)) {\n        let typed = true;\n        let issues;\n        const output = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const result = this.items[key]._parse(value2, config);\n          if (result.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!result.typed) {\n            typed = false;\n          }\n          output[key] = result.output;\n        }\n        if (this.rest && !(config?.abortEarly && issues)) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const result = this.rest._parse(value2, config);\n            if (result.issues) {\n              const pathItem = {\n                type: \"tuple\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of result.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                issues?.push(issue);\n              }\n              if (!issues) {\n                issues = result.issues;\n              }\n              if (config?.abortEarly) {\n                typed = false;\n                break;\n              }\n            }\n            if (!result.typed) {\n              typed = false;\n            }\n            output[key] = result.output;\n          }\n        }\n        if (typed) {\n          return pipeResult(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, tuple, input, config);\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    type: \"tuple\",\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (Array.isArray(input)) {\n        let typed = true;\n        let issues;\n        const output = [];\n        await Promise.all([\n          // Parse schema of each tuple item\n          Promise.all(\n            this.items.map(async (schema, key) => {\n              if (!(config?.abortEarly && issues)) {\n                const value2 = input[key];\n                const result = await schema._parse(value2, config);\n                if (!(config?.abortEarly && issues)) {\n                  if (result.issues) {\n                    const pathItem = {\n                      type: \"tuple\",\n                      origin: \"value\",\n                      input,\n                      key,\n                      value: value2\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (config?.abortEarly) {\n                      typed = false;\n                      throw null;\n                    }\n                  }\n                  if (!result.typed) {\n                    typed = false;\n                  }\n                  output[key] = result.output;\n                }\n              }\n            })\n          ),\n          // If necessary parse schema of each rest item\n          this.rest && Promise.all(\n            input.slice(this.items.length).map(async (value2, index) => {\n              if (!(config?.abortEarly && issues)) {\n                const key = this.items.length + index;\n                const result = await this.rest._parse(value2, config);\n                if (!(config?.abortEarly && issues)) {\n                  if (result.issues) {\n                    const pathItem = {\n                      type: \"tuple\",\n                      origin: \"value\",\n                      input,\n                      key,\n                      value: value2\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (config?.abortEarly) {\n                      typed = false;\n                      throw null;\n                    }\n                  }\n                  if (!result.typed) {\n                    typed = false;\n                  }\n                  output[key] = result.output;\n                }\n              }\n            })\n          )\n        ]).catch(() => null);\n        if (typed) {\n          return pipeResultAsync(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, tupleAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message) {\n  return {\n    type: \"undefined\",\n    expects: \"undefined\",\n    async: false,\n    message,\n    _parse(input, config) {\n      if (input === void 0) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, undefined_, input, config);\n    }\n  };\n}\n\n// src/schemas/undefined/undefinedAsync.ts\nfunction undefinedAsync(message) {\n  return {\n    type: \"undefined\",\n    expects: \"undefined\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      if (input === void 0) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, undefinedAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/union/utils/subissues/subissues.ts\nfunction subissues(results) {\n  let issues;\n  if (results) {\n    for (const result of results) {\n      if (issues) {\n        for (const issue of result.issues) {\n          issues.push(issue);\n        }\n      } else {\n        issues = result.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\nfunction union(options, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"union\",\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \"),\n    async: false,\n    options,\n    message,\n    pipe,\n    _parse(input, config) {\n      let validResult;\n      let untypedResults;\n      let typedResults;\n      for (const schema of this.options) {\n        const result = schema._parse(input, config);\n        if (result.typed) {\n          if (!result.issues) {\n            validResult = result;\n            break;\n          } else {\n            typedResults ? typedResults.push(result) : typedResults = [result];\n          }\n        } else {\n          untypedResults ? untypedResults.push(result) : untypedResults = [result];\n        }\n      }\n      if (validResult) {\n        return pipeResult(this, validResult.output, config);\n      }\n      if (typedResults?.length) {\n        const firstResult = typedResults[0];\n        return pipeResult(\n          this,\n          firstResult.output,\n          config,\n          // Hint: If there is more than one typed result, we use a general\n          // union issue with subissues because the issues could contradict\n          // each other.\n          typedResults.length === 1 ? firstResult.issues : schemaIssue(this, union, input, config, {\n            reason: \"union\",\n            issues: subissues(typedResults)\n          }).issues\n        );\n      }\n      if (untypedResults?.length === 1) {\n        return untypedResults[0];\n      }\n      return schemaIssue(this, union, input, config, {\n        issues: subissues(untypedResults)\n      });\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"union\",\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \"),\n    async: true,\n    options,\n    message,\n    pipe,\n    async _parse(input, config) {\n      let validResult;\n      let untypedResults;\n      let typedResults;\n      for (const schema of this.options) {\n        const result = await schema._parse(input, config);\n        if (result.typed) {\n          if (!result.issues) {\n            validResult = result;\n            break;\n          } else {\n            typedResults ? typedResults.push(result) : typedResults = [result];\n          }\n        } else {\n          untypedResults ? untypedResults.push(result) : untypedResults = [result];\n        }\n      }\n      if (validResult) {\n        return pipeResultAsync(this, validResult.output, config);\n      }\n      if (typedResults?.length) {\n        const firstResult = typedResults[0];\n        return pipeResultAsync(\n          this,\n          firstResult.output,\n          config,\n          // Hint: If there is more than one typed result, we use a general\n          // union issue with subissues because the issues could contradict\n          // each other.\n          typedResults.length === 1 ? firstResult.issues : schemaIssue(this, unionAsync, input, config, {\n            reason: \"union\",\n            issues: subissues(typedResults)\n          }).issues\n        );\n      }\n      if (untypedResults?.length === 1) {\n        return untypedResults[0];\n      }\n      return schemaIssue(this, unionAsync, input, config, {\n        issues: subissues(untypedResults)\n      });\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown(pipe) {\n  return {\n    type: \"unknown\",\n    expects: \"unknown\",\n    async: false,\n    pipe,\n    _parse(input, config) {\n      return pipeResult(this, input, config);\n    }\n  };\n}\n\n// src/schemas/unknown/unknownAsync.ts\nfunction unknownAsync(pipe) {\n  return {\n    type: \"unknown\",\n    expects: \"unknown\",\n    async: true,\n    pipe,\n    async _parse(input, config) {\n      return pipeResultAsync(this, input, config);\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, arg3, arg4) {\n  const [message, pipe] = defaultArgs(arg3, arg4);\n  let cachedExpectedKey;\n  return {\n    type: \"variant\",\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        if (this.key in input || !cachedExpectedKey) {\n          let expectedKey;\n          let variantResult;\n          const parseOptions = (options2) => {\n            for (const schema of options2) {\n              if (schema.type === \"object\") {\n                const keySchema = schema.entries[this.key];\n                const keyResult = keySchema._parse(\n                  input[this.key],\n                  config\n                );\n                if (!cachedExpectedKey) {\n                  expectedKey ? expectedKey.push(keySchema.expects) : expectedKey = [keySchema.expects];\n                }\n                if (!keyResult.issues) {\n                  const dataResult = schema._parse(input, config);\n                  if (!dataResult.issues) {\n                    variantResult = dataResult;\n                    break;\n                  }\n                  if (!variantResult || !variantResult.typed && dataResult.typed) {\n                    variantResult = dataResult;\n                  }\n                }\n              } else if (schema.type === \"variant\") {\n                parseOptions(schema.options);\n                if (variantResult && !variantResult.issues) {\n                  break;\n                }\n              }\n            }\n          };\n          parseOptions(this.options);\n          cachedExpectedKey = cachedExpectedKey || [...new Set(expectedKey)].join(\" | \");\n          if (variantResult) {\n            if (variantResult.typed) {\n              return pipeResult(\n                this,\n                variantResult.output,\n                config,\n                variantResult.issues\n              );\n            }\n            return variantResult;\n          }\n        }\n        const value2 = input[this.key];\n        return schemaIssue(this, variant, value2, config, {\n          expected: cachedExpectedKey,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: value2\n            }\n          ]\n        });\n      }\n      return schemaIssue(this, variant, input, config);\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, arg3, arg4) {\n  const [message, pipe] = defaultArgs(arg3, arg4);\n  let cachedExpectedKey;\n  return {\n    type: \"variant\",\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        if (this.key in input || !cachedExpectedKey) {\n          let expectedKey;\n          let variantResult;\n          const parseOptions = async (options2) => {\n            for (const schema of options2) {\n              if (schema.type === \"object\") {\n                const keySchema = schema.entries[this.key];\n                const keyResult = await keySchema._parse(\n                  input[this.key],\n                  config\n                );\n                if (!cachedExpectedKey) {\n                  expectedKey ? expectedKey.push(keySchema.expects) : expectedKey = [keySchema.expects];\n                }\n                if (!keyResult.issues) {\n                  const dataResult = await schema._parse(input, config);\n                  if (!dataResult.issues) {\n                    variantResult = dataResult;\n                    break;\n                  }\n                  if (!variantResult || !variantResult.typed && dataResult.typed) {\n                    variantResult = dataResult;\n                  }\n                }\n              } else if (schema.type === \"variant\") {\n                await parseOptions(schema.options);\n                if (variantResult && !variantResult.issues) {\n                  break;\n                }\n              }\n            }\n          };\n          await parseOptions(this.options);\n          cachedExpectedKey = cachedExpectedKey || [...new Set(expectedKey)].join(\" | \");\n          if (variantResult) {\n            if (variantResult.typed) {\n              return pipeResultAsync(\n                this,\n                variantResult.output,\n                config,\n                variantResult.issues\n              );\n            }\n            return variantResult;\n          }\n        }\n        const value2 = input[this.key];\n        return schemaIssue(this, variantAsync, value2, config, {\n          expected: cachedExpectedKey,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: value2\n            }\n          ]\n        });\n      }\n      return schemaIssue(this, variantAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/void/void.ts\nfunction void_(message) {\n  return {\n    type: \"void\",\n    expects: \"void\",\n    async: false,\n    message,\n    _parse(input, config) {\n      if (input === void 0) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, void_, input, config);\n    }\n  };\n}\n\n// src/schemas/void/voidAsync.ts\nfunction voidAsync(message) {\n  return {\n    type: \"void\",\n    expects: \"void\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      if (input === void 0) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, voidAsync, input, config);\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema) {\n  return picklist(\n    Object.keys(schema.entries)\n  );\n}\n\n// src/methods/merge/merge.ts\nfunction merge(schemas, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/merge/mergeAsync.ts\nfunction mergeAsync(schemas, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/omit/omitAsync.ts\nfunction omitAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config) {\n  const result = schema._parse(input, getGlobalConfig(config));\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config) {\n  const result = await schema._parse(input, getGlobalConfig(config));\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/pick/pickAsync.ts\nfunction pickAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, config) {\n  const result = schema._parse(input, getGlobalConfig(config));\n  return {\n    typed: result.typed,\n    success: !result.issues,\n    output: result.output,\n    issues: result.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, config) {\n  const result = await schema._parse(input, getGlobalConfig(config));\n  return {\n    typed: result.typed,\n    success: !result.issues,\n    output: result.output,\n    issues: result.issues\n  };\n}\n\n// src/methods/transform/transform.ts\nfunction transform(schema, action, arg1) {\n  return {\n    ...schema,\n    _parse(input, config) {\n      const result = schema._parse(input, config);\n      if (result.issues) {\n        result.typed = false;\n      } else {\n        result.output = action(result.output, { issues: result.issues });\n        if (arg1) {\n          if (Array.isArray(arg1)) {\n            return pipeResult(\n              { type: typeof result.output, pipe: arg1 },\n              result.output,\n              config\n            );\n          }\n          return arg1._parse(result.output, config);\n        }\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/transform/transformAsync.ts\nfunction transformAsync(schema, action, arg1) {\n  return {\n    ...schema,\n    async: true,\n    async _parse(input, config) {\n      const result = await schema._parse(input, config);\n      if (result.issues) {\n        result.typed = false;\n      } else {\n        result.output = await action(result.output, { issues: result.issues });\n        if (arg1) {\n          if (Array.isArray(arg1)) {\n            return pipeResultAsync(\n              { type: typeof result.output, pipe: arg1 },\n              result.output,\n              config\n            );\n          }\n          return arg1._parse(result.output, config);\n        }\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\n\n// src/regex.ts\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\\d]{2}(?:[A-Z\\d]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar HEXADECIMAL_REGEX = /^(0h|0x)?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#([\\da-f]{3}|[\\da-f]{4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{2}(?:[ /|-]?\\d{6}){2}[ /|-]?\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?Z$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar OCTAL_REGEX = /^(0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/transformations/toCustom/toCustom.ts\nfunction toCustom(action) {\n  return {\n    type: \"to_custom\",\n    async: false,\n    _parse(input) {\n      return actionOutput(action(input));\n    }\n  };\n}\n\n// src/transformations/toCustom/toCustomAsync.ts\nfunction toCustomAsync(action) {\n  return {\n    type: \"to_custom\",\n    async: true,\n    async _parse(input) {\n      return actionOutput(await action(input));\n    }\n  };\n}\n\n// src/transformations/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return {\n    type: \"to_lower_case\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.toLocaleLowerCase());\n    }\n  };\n}\n\n// src/transformations/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return {\n    type: \"to_max_value\",\n    async: false,\n    requirement,\n    _parse(input) {\n      return actionOutput(input > this.requirement ? this.requirement : input);\n    }\n  };\n}\n\n// src/transformations/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return {\n    type: \"to_min_value\",\n    async: false,\n    requirement,\n    _parse(input) {\n      return actionOutput(input < this.requirement ? this.requirement : input);\n    }\n  };\n}\n\n// src/transformations/toTrimmed/toTrimmed.ts\nfunction toTrimmed() {\n  return {\n    type: \"to_trimmed\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.trim());\n    }\n  };\n}\n\n// src/transformations/toTrimmedEnd/toTrimmedEnd.ts\nfunction toTrimmedEnd() {\n  return {\n    type: \"to_trimmed_end\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.trimEnd());\n    }\n  };\n}\n\n// src/transformations/toTrimmedStart/toTrimmedStart.ts\nfunction toTrimmedStart() {\n  return {\n    type: \"to_trimmed_start\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.trimStart());\n    }\n  };\n}\n\n// src/transformations/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return {\n    type: \"to_upper_case\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.toUpperCase());\n    }\n  };\n}\n\n// src/validations/bic/bic.ts\nfunction bic(message) {\n  return {\n    type: \"bic\",\n    expects: null,\n    async: false,\n    message,\n    requirement: BIC_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, bic, input, \"BIC\");\n    }\n  };\n}\n\n// src/validations/bytes/bytes.ts\nfunction bytes(requirement, message) {\n  return {\n    type: \"bytes\",\n    expects: `${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      const length2 = new TextEncoder().encode(input).length;\n      if (length2 === this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, bytes, input, \"bytes\", `${length2}`);\n    }\n  };\n}\n\n// src/validations/creditCard/creditCard.ts\nvar SANITIZE_REGEX = /[- ]+/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  /^5[1-5]\\d{2}|(222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(6[27]\\d{14}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message) {\n  return {\n    type: \"credit_card\",\n    expects: null,\n    async: false,\n    message,\n    requirement: (input) => {\n      const sanitized = input.replace(SANITIZE_REGEX, \"\");\n      return PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && isLuhnAlgo(sanitized);\n    },\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, creditCard, input, \"credit card\");\n    }\n  };\n}\n\n// src/validations/cuid2/cuid2.ts\nfunction cuid2(message) {\n  return {\n    type: \"cuid2\",\n    expects: null,\n    async: false,\n    message,\n    requirement: CUID2_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, cuid2, input, \"Cuid2\");\n    }\n  };\n}\n\n// src/validations/custom/custom.ts\nfunction custom(requirement, message) {\n  return {\n    type: \"custom\",\n    expects: null,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, custom, input, \"input\");\n    }\n  };\n}\n\n// src/validations/custom/customAsync.ts\nfunction customAsync(requirement, message) {\n  return {\n    type: \"custom\",\n    expects: null,\n    async: true,\n    message,\n    requirement,\n    async _parse(input) {\n      if (await this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, customAsync, input, \"input\");\n    }\n  };\n}\n\n// src/validations/decimal/decimal.ts\nfunction decimal(message) {\n  return {\n    type: \"decimal\",\n    expects: null,\n    async: false,\n    message,\n    requirement: DECIMAL_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, decimal, input, \"decimal\");\n    }\n  };\n}\n\n// src/validations/email/email.ts\nfunction email(message) {\n  return {\n    type: \"email\",\n    expects: null,\n    async: false,\n    message,\n    requirement: EMAIL_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, email, input, \"email\");\n    }\n  };\n}\n\n// src/validations/emoji/emoji.ts\nfunction emoji(message) {\n  return {\n    type: \"emoji\",\n    expects: null,\n    async: false,\n    message,\n    requirement: EMOJI_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, emoji, input, \"emoji\");\n    }\n  };\n}\n\n// src/validations/endsWith/endsWith.ts\nfunction endsWith(requirement, message) {\n  return {\n    type: \"ends_with\",\n    expects: `\"${requirement}\"`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.endsWith(this.requirement)) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        endsWith,\n        input,\n        \"end\",\n        `\"${input.slice(-this.requirement.length)}\"`\n      );\n    }\n  };\n}\n\n// src/validations/every/every.ts\nfunction every(requirement, message) {\n  return {\n    type: \"every\",\n    expects: null,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.every(this.requirement)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, every, input, \"input\");\n    }\n  };\n}\n\n// src/validations/excludes/excludes.ts\nfunction excludes(requirement, message) {\n  const received = stringify(requirement);\n  return {\n    type: \"excludes\",\n    expects: `!${received}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (!input.includes(this.requirement)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, excludes, input, \"content\", received);\n    }\n  };\n}\n\n// src/validations/finite/finite.ts\nfunction finite(message) {\n  return {\n    type: \"finite\",\n    expects: null,\n    async: false,\n    message,\n    requirement: Number.isFinite,\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, finite, input, \"finite\");\n    }\n  };\n}\n\n// src/validations/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\nfunction hash(types, message) {\n  return {\n    type: \"hash\",\n    expects: null,\n    async: false,\n    message,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, hash, input, \"hash\");\n    }\n  };\n}\n\n// src/validations/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message) {\n  return {\n    type: \"hexadecimal\",\n    expects: null,\n    async: false,\n    message,\n    requirement: HEXADECIMAL_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, hexadecimal, input, \"hexadecimal\");\n    }\n  };\n}\n\n// src/validations/hexColor/hexColor.ts\nfunction hexColor(message) {\n  return {\n    type: \"hex_color\",\n    expects: null,\n    async: false,\n    message,\n    requirement: HEX_COLOR_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, hexColor, input, \"hex color\");\n    }\n  };\n}\n\n// src/validations/imei/imei.ts\nfunction imei(message) {\n  return {\n    type: \"imei\",\n    expects: null,\n    async: false,\n    message,\n    requirement: [IMEI_REGEX, isLuhnAlgo],\n    _parse(input) {\n      if (this.requirement[0].test(input) && this.requirement[1](input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, imei, input, \"IMEI\");\n    }\n  };\n}\n\n// src/validations/includes/includes.ts\nfunction includes(requirement, message) {\n  const expects = stringify(requirement);\n  return {\n    type: \"includes\",\n    expects,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.includes(this.requirement)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, includes, input, \"content\", `!${expects}`);\n    }\n  };\n}\n\n// src/validations/integer/integer.ts\nfunction integer(message) {\n  return {\n    type: \"integer\",\n    expects: null,\n    async: false,\n    message,\n    requirement: Number.isInteger,\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, integer, input, \"integer\");\n    }\n  };\n}\n\n// src/validations/ip/ip.ts\nfunction ip(message) {\n  return {\n    type: \"ip\",\n    expects: null,\n    async: false,\n    message,\n    // TODO: It is strange that we have an OR relationship between requirements\n    requirement: [IPV4_REGEX, IPV6_REGEX],\n    _parse(input) {\n      if (this.requirement[0].test(input) || this.requirement[1].test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, ip, input, \"IP\");\n    }\n  };\n}\n\n// src/validations/ipv4/ipv4.ts\nfunction ipv4(message) {\n  return {\n    type: \"ipv4\",\n    expects: null,\n    async: false,\n    message,\n    requirement: IPV4_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, ipv4, input, \"IPv4\");\n    }\n  };\n}\n\n// src/validations/ipv6/ipv6.ts\nfunction ipv6(message) {\n  return {\n    type: \"ipv6\",\n    expects: null,\n    async: false,\n    message,\n    requirement: IPV6_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, ipv6, input, \"IPv6\");\n    }\n  };\n}\n\n// src/validations/isoDate/isoDate.ts\nfunction isoDate(message) {\n  return {\n    type: \"iso_date\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_DATE_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoDate, input, \"date\");\n    }\n  };\n}\n\n// src/validations/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message) {\n  return {\n    type: \"iso_date_time\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_DATE_TIME_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoDateTime, input, \"date-time\");\n    }\n  };\n}\n\n// src/validations/isoTime/isoTime.ts\nfunction isoTime(message) {\n  return {\n    type: \"iso_time\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_TIME_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoTime, input, \"time\");\n    }\n  };\n}\n\n// src/validations/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message) {\n  return {\n    type: \"iso_time_second\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_TIME_SECOND_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoTimeSecond, input, \"time second\");\n    }\n  };\n}\n\n// src/validations/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message) {\n  return {\n    type: \"iso_timestamp\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_TIMESTAMP_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoTimestamp, input, \"timestamp\");\n    }\n  };\n}\n\n// src/validations/isoWeek/isoWeek.ts\nfunction isoWeek(message) {\n  return {\n    type: \"iso_week\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_WEEK_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoWeek, input, \"week\");\n    }\n  };\n}\n\n// src/validations/length/length.ts\nfunction length(requirement, message) {\n  return {\n    type: \"length\",\n    expects: `${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.length === this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, length, input, \"length\", `${input.length}`);\n    }\n  };\n}\n\n// src/validations/mac/mac.ts\nfunction mac(message) {\n  return {\n    type: \"mac\",\n    expects: null,\n    async: false,\n    message,\n    // TODO: It is strange that we have an OR relationship between requirements\n    requirement: [MAC48_REGEX, MAC64_REGEX],\n    _parse(input) {\n      if (this.requirement[0].test(input) || this.requirement[1].test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, mac, input, \"MAC\");\n    }\n  };\n}\n\n// src/validations/mac48/mac48.ts\nfunction mac48(message) {\n  return {\n    type: \"mac48\",\n    expects: null,\n    async: false,\n    message,\n    requirement: MAC48_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, mac48, input, \"48-bit MAC\");\n    }\n  };\n}\n\n// src/validations/mac64/mac64.ts\nfunction mac64(message) {\n  return {\n    type: \"mac64\",\n    expects: null,\n    async: false,\n    message,\n    requirement: MAC64_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, mac64, input, \"64-bit MAC\");\n    }\n  };\n}\n\n// src/validations/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message) {\n  return {\n    type: \"max_bytes\",\n    expects: `<=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      const length2 = new TextEncoder().encode(input).length;\n      if (length2 <= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, maxBytes, input, \"bytes\", `${length2}`);\n    }\n  };\n}\n\n// src/validations/maxLength/maxLength.ts\nfunction maxLength(requirement, message) {\n  return {\n    type: \"max_length\",\n    expects: `<=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.length <= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, maxLength, input, \"length\", `${input.length}`);\n    }\n  };\n}\n\n// src/validations/maxSize/maxSize.ts\nfunction maxSize(requirement, message) {\n  return {\n    type: \"max_size\",\n    expects: `<=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.size <= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, maxSize, input, \"size\", `${input.size}`);\n    }\n  };\n}\n\n// src/validations/maxValue/maxValue.ts\nfunction maxValue(requirement, message) {\n  return {\n    type: \"max_value\",\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : stringify(requirement)}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input <= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        maxValue,\n        input,\n        \"value\",\n        input instanceof Date ? input.toJSON() : stringify(input)\n      );\n    }\n  };\n}\n\n// src/validations/minBytes/minBytes.ts\nfunction minBytes(requirement, message) {\n  return {\n    type: \"min_bytes\",\n    expects: `>=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      const length2 = new TextEncoder().encode(input).length;\n      if (length2 >= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, minBytes, input, \"bytes\", `${length2}`);\n    }\n  };\n}\n\n// src/validations/mimeType/mimeType.ts\nfunction mimeType(requirement, message) {\n  return {\n    type: \"mime_type\",\n    expects: requirement.map((option) => `\"${option}\"`).join(\" | \"),\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (this.requirement.includes(input.type)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, mimeType, input, \"MIME type\");\n    }\n  };\n}\n\n// src/validations/minLength/minLength.ts\nfunction minLength(requirement, message) {\n  return {\n    type: \"min_length\",\n    expects: `>=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.length >= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, minLength, input, \"length\", `${input.length}`);\n    }\n  };\n}\n\n// src/validations/minSize/minSize.ts\nfunction minSize(requirement, message) {\n  return {\n    type: \"min_size\",\n    expects: `>=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.size >= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, minSize, input, \"size\", `${input.size}`);\n    }\n  };\n}\n\n// src/validations/minValue/minValue.ts\nfunction minValue(requirement, message) {\n  return {\n    type: \"min_value\",\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : stringify(requirement)}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input >= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        minValue,\n        input,\n        \"value\",\n        input instanceof Date ? input.toJSON() : stringify(input)\n      );\n    }\n  };\n}\n\n// src/validations/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message) {\n  return {\n    type: \"multiple_of\",\n    expects: `%${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input % this.requirement === 0) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, multipleOf, input, \"multiple\", `${input}`);\n    }\n  };\n}\n\n// src/validations/notBytes/notBytes.ts\nfunction notBytes(requirement, message) {\n  return {\n    type: \"not_bytes\",\n    expects: `!${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      const length2 = new TextEncoder().encode(input).length;\n      if (length2 !== this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, notBytes, input, \"bytes\", `${length2}`);\n    }\n  };\n}\n\n// src/validations/notLength/notLength.ts\nfunction notLength(requirement, message) {\n  return {\n    type: \"not_length\",\n    expects: `!${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.length !== this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, notLength, input, \"length\", `${input.length}`);\n    }\n  };\n}\n\n// src/validations/notSize/notSize.ts\nfunction notSize(requirement, message) {\n  return {\n    type: \"not_size\",\n    expects: `!${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.size !== this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, notSize, input, \"size\", `${input.size}`);\n    }\n  };\n}\n\n// src/validations/notValue/notValue.ts\nfunction notValue(requirement, message) {\n  return {\n    type: \"not_value\",\n    expects: `!${requirement instanceof Date ? requirement.toJSON() : stringify(requirement)}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input < this.requirement || input > this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        notValue,\n        input,\n        \"value\",\n        input instanceof Date ? input.toJSON() : stringify(input)\n      );\n    }\n  };\n}\n\n// src/validations/octal/octal.ts\nfunction octal(message) {\n  return {\n    type: \"octal\",\n    expects: null,\n    async: false,\n    message,\n    requirement: OCTAL_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, octal, input, \"octal\");\n    }\n  };\n}\n\n// src/validations/regex/regex.ts\nfunction regex(requirement, message) {\n  return {\n    type: \"regex\",\n    expects: `${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, regex, input, \"format\");\n    }\n  };\n}\n\n// src/validations/safeInteger/safeInteger.ts\nfunction safeInteger(message) {\n  return {\n    type: \"safe_integer\",\n    expects: null,\n    async: false,\n    message,\n    requirement: Number.isSafeInteger,\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, safeInteger, input, \"safe integer\");\n    }\n  };\n}\n\n// src/validations/size/size.ts\nfunction size(requirement, message) {\n  return {\n    type: \"size\",\n    expects: `${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.size === this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, size, input, \"size\", `${input.size}`);\n    }\n  };\n}\n\n// src/validations/some/some.ts\nfunction some(requirement, message) {\n  return {\n    type: \"some\",\n    expects: null,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.some(this.requirement)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, some, input, \"input\");\n    }\n  };\n}\n\n// src/validations/startsWith/startsWith.ts\nfunction startsWith(requirement, message) {\n  return {\n    type: \"starts_with\",\n    expects: `\"${requirement}\"`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.startsWith(this.requirement)) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        startsWith,\n        input,\n        \"start\",\n        `\"${input.slice(0, this.requirement.length)}\"`\n      );\n    }\n  };\n}\n\n// src/validations/ulid/ulid.ts\nfunction ulid(message) {\n  return {\n    type: \"ulid\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ULID_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, ulid, input, \"ULID\");\n    }\n  };\n}\n\n// src/validations/url/url.ts\nfunction url(message) {\n  return {\n    type: \"url\",\n    expects: null,\n    async: false,\n    message,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, url, input, \"URL\");\n    }\n  };\n}\n\n// src/validations/uuid/uuid.ts\nfunction uuid(message) {\n  return {\n    type: \"uuid\",\n    expects: null,\n    async: false,\n    message,\n    requirement: UUID_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, uuid, input, \"UUID\");\n    }\n  };\n}\n\n// src/validations/value/value.ts\nfunction value(requirement, message) {\n  return {\n    type: \"value\",\n    expects: `${requirement instanceof Date ? requirement.toJSON() : stringify(requirement)}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input <= this.requirement && input >= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        value,\n        input,\n        \"value\",\n        input instanceof Date ? input.toJSON() : stringify(input)\n      );\n    }\n  };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmFsaWJvdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQSx5Q0FBeUMsS0FBSztBQUM5QztBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQTRDO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNLHVFQUF1RSxNQUFNO0FBQ3BIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWSxJQUFJLG9DQUFvQyx1QkFBdUIsYUFBYSxVQUFVLFNBQVM7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVSxlQUFlLFNBQVM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDhCQUE4QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0JBQW9CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0RBQWtEO0FBQ3BFLGtCQUFrQjtBQUNsQiw2QkFBNkIsK0JBQStCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQWtEO0FBQ3RFLG9CQUFvQjtBQUNwQiwrQkFBK0IsK0JBQStCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsb0JBQW9CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLDRCQUE0QjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLDRCQUE0QjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsNkJBQTZCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsNkJBQTZCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGdEQUFnRCx1QkFBdUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdDQUF3QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixzREFBc0QsdUJBQXVCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3Q0FBd0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixFQUFFLGNBQWMsRUFBRSxXQUFXLEVBQUU7QUFDdkQ7QUFDQTtBQUNBLDJFQUEyRSxHQUFHO0FBQzlFLHdCQUF3QixzQkFBc0IsR0FBRyxnQkFBZ0I7QUFDakU7QUFDQSxrQ0FBa0MsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRTtBQUNyRSxzQkFBc0IsRUFBRSxhQUFhLEVBQUUsRUFBRSxFQUFFO0FBQzNDO0FBQ0E7QUFDQSxpRkFBaUYsRUFBRTtBQUNuRjtBQUNBLGlDQUFpQyxJQUFJLEdBQUcsRUFBRSxRQUFRLElBQUksWUFBWSxJQUFJLEdBQUcsSUFBSSxhQUFhLElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSSxZQUFZLElBQUksR0FBRyxJQUFJLFlBQVksSUFBSSxFQUFFLElBQUksWUFBWSxJQUFJLEdBQUcsSUFBSSxZQUFZLElBQUksRUFBRSxJQUFJLFlBQVksSUFBSSxHQUFHLElBQUksWUFBWSxJQUFJLEVBQUUsSUFBSSxZQUFZLElBQUksR0FBRyxJQUFJLFlBQVksSUFBSSxFQUFFLElBQUksU0FBUyxJQUFJLGFBQWEsSUFBSSxFQUFFLElBQUksaUJBQWlCLElBQUksRUFBRSxJQUFJLHFCQUFxQixJQUFJLEVBQUUsSUFBSSxpQkFBaUIsRUFBRSxNQUFNLElBQUksMENBQTBDLEVBQUUsMENBQTBDLElBQUksR0FBRyxJQUFJLHNDQUFzQyxFQUFFO0FBQzFpQiwwQkFBMEIsRUFBRTtBQUM1QiwrQkFBK0IsRUFBRTtBQUNqQztBQUNBLDZEQUE2RCxFQUFFO0FBQy9ELCtCQUErQixFQUFFLDBFQUEwRSxFQUFFLFFBQVEsSUFBSTtBQUN6SCwwQkFBMEIsRUFBRTtBQUM1QiwrQkFBK0IsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFO0FBQy9HLCtCQUErQixFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUU7QUFDOUk7QUFDQSxxQ0FBcUMsR0FBRztBQUN4QywyQkFBMkIsRUFBRSxZQUFZLEVBQUUsRUFBRSxFQUFFLFNBQVMsR0FBRzs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksR0FBRztBQUNmO0FBQ0EseUJBQXlCLEdBQUc7QUFDNUI7QUFDQSxnQkFBZ0IsRUFBRSxJQUFJLE1BQU07QUFDNUI7QUFDQSxzQkFBc0IsRUFBRSxJQUFJLEdBQUc7QUFDL0I7QUFDQSxhQUFhLEVBQUUsMkJBQTJCLEVBQUUsa0JBQWtCLEdBQUc7QUFDakU7QUFDQSxhQUFhLEdBQUcsTUFBTSxNQUFNO0FBQzVCO0FBQ0EsUUFBUSxHQUFHLE1BQU0sSUFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQ0FBc0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEVBQUUsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFFBQVE7QUFDdkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxRQUFRO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGFBQWE7QUFDM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsV0FBVztBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNEVBQTRFO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFFBQVE7QUFDcEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGFBQWE7QUFDM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsV0FBVztBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNEVBQTRFO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxNQUFNO0FBQ3ZFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsUUFBUTtBQUNwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxhQUFhO0FBQzNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVc7QUFDckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDRFQUE0RTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3Q0FBd0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEVBQTRFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEyTkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90YW56aXN0cmV0dG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy92YWxpYm90L2Rpc3QvaW5kZXguanM/ODhmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZXJyb3IvZmxhdHRlbi9mbGF0dGVuLnRzXG5mdW5jdGlvbiBmbGF0dGVuKGFyZzEpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5KGFyZzEpID8gYXJnMSA6IGFyZzEuaXNzdWVzKS5yZWR1Y2UoXG4gICAgKGZsYXRFcnJvcnMsIGlzc3VlKSA9PiB7XG4gICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICBpZiAoaXNzdWUucGF0aC5ldmVyeShcbiAgICAgICAgICAoeyBrZXkgfSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Yga2V5ID09PSBcIm51bWJlclwiXG4gICAgICAgICkpIHtcbiAgICAgICAgICBjb25zdCBwYXRoID0gaXNzdWUucGF0aC5tYXAoKHsga2V5IH0pID0+IGtleSkuam9pbihcIi5cIik7XG4gICAgICAgICAgaWYgKGZsYXRFcnJvcnMubmVzdGVkW3BhdGhdKSB7XG4gICAgICAgICAgICBmbGF0RXJyb3JzLm5lc3RlZFtwYXRoXS5wdXNoKGlzc3VlLm1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbGF0RXJyb3JzLm5lc3RlZFtwYXRoXSA9IFtpc3N1ZS5tZXNzYWdlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmbGF0RXJyb3JzLnJvb3QpIHtcbiAgICAgICAgICBmbGF0RXJyb3JzLnJvb3QucHVzaChpc3N1ZS5tZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGF0RXJyb3JzLnJvb3QgPSBbaXNzdWUubWVzc2FnZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmbGF0RXJyb3JzO1xuICAgIH0sXG4gICAgeyBuZXN0ZWQ6IHt9IH1cbiAgKTtcbn1cblxuLy8gc3JjL2Vycm9yL1ZhbGlFcnJvci9WYWxpRXJyb3IudHNcbnZhciBWYWxpRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgaXNzdWVzO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFZhbGlib3QgZXJyb3Igd2l0aCB1c2VmdWwgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBpc3N1ZXMgVGhlIGVycm9yIGlzc3Vlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGlzc3Vlcykge1xuICAgIHN1cGVyKGlzc3Vlc1swXS5tZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlZhbGlFcnJvclwiO1xuICAgIHRoaXMuaXNzdWVzID0gaXNzdWVzO1xuICB9XG59O1xuXG4vLyBzcmMvbWV0aG9kcy9icmFuZC9icmFuZC50c1xudmFyIEJyYW5kU3ltYm9sID0gU3ltYm9sKFwiYnJhbmRcIik7XG5mdW5jdGlvbiBicmFuZChzY2hlbWEsIG5hbWUpIHtcbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxuLy8gc3JjL21ldGhvZHMvY29lcmNlL2NvZXJjZS50c1xuZnVuY3Rpb24gY29lcmNlKHNjaGVtYSwgYWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICByZXR1cm4gc2NoZW1hLl9wYXJzZShhY3Rpb24oaW5wdXQpLCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvY29lcmNlL2NvZXJjZUFzeW5jLnRzXG5mdW5jdGlvbiBjb2VyY2VBc3luYyhzY2hlbWEsIGFjdGlvbikge1xuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgcmV0dXJuIHNjaGVtYS5fcGFyc2UoYXdhaXQgYWN0aW9uKGlucHV0KSwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9hY3Rpb25Jc3N1ZS9hY3Rpb25Jc3N1ZS50c1xuZnVuY3Rpb24gYWN0aW9uSXNzdWUoY29udGV4dCwgcmVmZXJlbmNlLCBpbnB1dCwgbGFiZWwsIHJlY2VpdmVkKSB7XG4gIHJldHVybiB7XG4gICAgaXNzdWVzOiBbeyBjb250ZXh0LCByZWZlcmVuY2UsIGlucHV0LCBsYWJlbCwgcmVjZWl2ZWQgfV1cbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2FjdGlvbk91dHB1dC9hY3Rpb25PdXRwdXQudHNcbmZ1bmN0aW9uIGFjdGlvbk91dHB1dChvdXRwdXQpIHtcbiAgcmV0dXJuIHsgb3V0cHV0IH07XG59XG5cbi8vIHNyYy91dGlscy9kZWZhdWx0QXJncy9kZWZhdWx0QXJncy50c1xuZnVuY3Rpb24gZGVmYXVsdEFyZ3MoYXJnMSwgYXJnMikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcxKSA/IFt2b2lkIDAsIGFyZzFdIDogW2FyZzEsIGFyZzJdO1xufVxuXG4vLyBzcmMvc3RvcmFnZXMvZ2xvYmFsQ29uZmlnL2dsb2JhbENvbmZpZy50c1xudmFyIHN0b3JlO1xuZnVuY3Rpb24gc2V0R2xvYmFsQ29uZmlnKGNvbmZpZykge1xuICBzdG9yZSA9IHsgLi4uc3RvcmUsIC4uLmNvbmZpZyB9O1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsQ29uZmlnKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIGxhbmc6IGNvbmZpZz8ubGFuZyA/PyBzdG9yZT8ubGFuZyxcbiAgICBtZXNzYWdlOiBjb25maWc/Lm1lc3NhZ2UsXG4gICAgYWJvcnRFYXJseTogY29uZmlnPy5hYm9ydEVhcmx5ID8/IHN0b3JlPy5hYm9ydEVhcmx5LFxuICAgIGFib3J0UGlwZUVhcmx5OiBjb25maWc/LmFib3J0UGlwZUVhcmx5ID8/IHN0b3JlPy5hYm9ydFBpcGVFYXJseSxcbiAgICBza2lwUGlwZTogY29uZmlnPy5za2lwUGlwZSA/PyBzdG9yZT8uc2tpcFBpcGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUdsb2JhbENvbmZpZygpIHtcbiAgc3RvcmUgPSB2b2lkIDA7XG59XG5cbi8vIHNyYy9zdG9yYWdlcy9nbG9iYWxNZXNzYWdlL2dsb2JhbE1lc3NhZ2UudHNcbnZhciBzdG9yZTI7XG5mdW5jdGlvbiBzZXRHbG9iYWxNZXNzYWdlKG1lc3NhZ2UsIGxhbmcpIHtcbiAgaWYgKCFzdG9yZTIpXG4gICAgc3RvcmUyID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgc3RvcmUyLnNldChsYW5nLCBtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbE1lc3NhZ2UobGFuZykge1xuICByZXR1cm4gc3RvcmUyPy5nZXQobGFuZyk7XG59XG5mdW5jdGlvbiBkZWxldGVHbG9iYWxNZXNzYWdlKGxhbmcpIHtcbiAgc3RvcmUyPy5kZWxldGUobGFuZyk7XG59XG5cbi8vIHNyYy9zdG9yYWdlcy9zY2hlbWFNZXNzYWdlL3NjaGVtYU1lc3NhZ2UudHNcbnZhciBzdG9yZTM7XG5mdW5jdGlvbiBzZXRTY2hlbWFNZXNzYWdlKG1lc3NhZ2UsIGxhbmcpIHtcbiAgaWYgKCFzdG9yZTMpXG4gICAgc3RvcmUzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgc3RvcmUzLnNldChsYW5nLCBtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIGdldFNjaGVtYU1lc3NhZ2UobGFuZykge1xuICByZXR1cm4gc3RvcmUzPy5nZXQobGFuZyk7XG59XG5mdW5jdGlvbiBkZWxldGVTY2hlbWFNZXNzYWdlKGxhbmcpIHtcbiAgc3RvcmUzPy5kZWxldGUobGFuZyk7XG59XG5cbi8vIHNyYy9zdG9yYWdlcy9zcGVjaWZpY01lc3NhZ2Uvc3BlY2lmaWNNZXNzYWdlLnRzXG52YXIgc3RvcmU0O1xuZnVuY3Rpb24gc2V0U3BlY2lmaWNNZXNzYWdlKHJlZmVyZW5jZSwgbWVzc2FnZSwgbGFuZykge1xuICBpZiAoIXN0b3JlNClcbiAgICBzdG9yZTQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBpZiAoIXN0b3JlNC5nZXQocmVmZXJlbmNlKSlcbiAgICBzdG9yZTQuc2V0KHJlZmVyZW5jZSwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIHN0b3JlNC5nZXQocmVmZXJlbmNlKS5zZXQobGFuZywgbWVzc2FnZSk7XG59XG5mdW5jdGlvbiBnZXRTcGVjaWZpY01lc3NhZ2UocmVmZXJlbmNlLCBsYW5nKSB7XG4gIHJldHVybiBzdG9yZTQ/LmdldChyZWZlcmVuY2UpPy5nZXQobGFuZyk7XG59XG5mdW5jdGlvbiBkZWxldGVTcGVjaWZpY01lc3NhZ2UocmVmZXJlbmNlLCBsYW5nKSB7XG4gIHN0b3JlND8uZ2V0KHJlZmVyZW5jZSk/LmRlbGV0ZShsYW5nKTtcbn1cblxuLy8gc3JjL3V0aWxzL2kxOG4vaTE4bi50c1xuZnVuY3Rpb24gaTE4bihzY2hlbWEsIGNvbnRleHQsIHJlZmVyZW5jZSwgY29uZmlnLCBpc3N1ZSkge1xuICBjb25zdCBtZXNzYWdlID0gY29udGV4dC5tZXNzYWdlID8/IGdldFNwZWNpZmljTWVzc2FnZShyZWZlcmVuY2UsIGlzc3VlLmxhbmcpID8/IChzY2hlbWEgPyBnZXRTY2hlbWFNZXNzYWdlKGlzc3VlLmxhbmcpIDogbnVsbCkgPz8gY29uZmlnPy5tZXNzYWdlID8/IGdldEdsb2JhbE1lc3NhZ2UoaXNzdWUubGFuZykgPz8gaXNzdWUubWVzc2FnZTtcbiAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIgPyBtZXNzYWdlKGlzc3VlKSA6IG1lc3NhZ2U7XG59XG5cbi8vIHNyYy91dGlscy9pc0x1aG5BbGdvL2lzTHVobkFsZ28udHNcbnZhciBOT05fRElHSVRfUkVHRVggPSAvXFxEL2d1O1xuZnVuY3Rpb24gaXNMdWhuQWxnbyhpbnB1dCkge1xuICBjb25zdCBudW1iZXIyID0gaW5wdXQucmVwbGFjZShOT05fRElHSVRfUkVHRVgsIFwiXCIpO1xuICBsZXQgbGVuZ3RoMiA9IG51bWJlcjIubGVuZ3RoO1xuICBsZXQgYml0ID0gMTtcbiAgbGV0IHN1bSA9IDA7XG4gIHdoaWxlIChsZW5ndGgyKSB7XG4gICAgY29uc3QgdmFsdWUyID0gK251bWJlcjJbLS1sZW5ndGgyXTtcbiAgICBiaXQgXj0gMTtcbiAgICBzdW0gKz0gYml0ID8gWzAsIDIsIDQsIDYsIDgsIDEsIDMsIDUsIDcsIDldW3ZhbHVlMl0gOiB2YWx1ZTI7XG4gIH1cbiAgcmV0dXJuIHN1bSAlIDEwID09PSAwO1xufVxuXG4vLyBzcmMvdXRpbHMvaXNPZlR5cGUvaXNPZlR5cGUudHNcbmZ1bmN0aW9uIGlzT2ZUeXBlKHR5cGUsIG9iamVjdDIpIHtcbiAgcmV0dXJuIG9iamVjdDIudHlwZSA9PT0gdHlwZTtcbn1cblxuLy8gc3JjL3V0aWxzL3NjaGVtYVJlc3VsdC9zY2hlbWFSZXN1bHQudHNcbmZ1bmN0aW9uIHNjaGVtYVJlc3VsdCh0eXBlZCwgb3V0cHV0LCBpc3N1ZXMpIHtcbiAgcmV0dXJuIHsgdHlwZWQsIG91dHB1dCwgaXNzdWVzIH07XG59XG5cbi8vIHNyYy91dGlscy9zdHJpbmdpZnkvc3RyaW5naWZ5LnRzXG5mdW5jdGlvbiBzdHJpbmdpZnkoaW5wdXQpIHtcbiAgbGV0IHR5cGUgPSB0eXBlb2YgaW5wdXQ7XG4gIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgdHlwZSA9IGlucHV0ID8gT2JqZWN0LmdldFByb3RvdHlwZU9mKGlucHV0KS5jb25zdHJ1Y3Rvci5uYW1lIDogXCJudWxsXCI7XG4gIH1cbiAgcmV0dXJuIHR5cGUgPT09IFwic3RyaW5nXCIgPyBgXCIke2lucHV0fVwiYCA6IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJiaWdpbnRcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiA/IGAke2lucHV0fWAgOiB0eXBlO1xufVxuXG4vLyBzcmMvdXRpbHMvcGlwZVJlc3VsdC91dGlscy9waXBlSXNzdWUvcGlwZUlzc3VlLnRzXG5mdW5jdGlvbiBwaXBlSXNzdWUoY29udGV4dCwgY29uZmlnLCBpc3N1ZSkge1xuICBjb25zdCByZWNlaXZlZCA9IGlzc3VlLnJlY2VpdmVkID8/IHN0cmluZ2lmeShpc3N1ZS5pbnB1dCk7XG4gIGNvbnN0IHNjaGVtYUlzc3VlMiA9IHtcbiAgICByZWFzb246IGNvbnRleHQudHlwZSxcbiAgICBjb250ZXh0OiBpc3N1ZS5jb250ZXh0LnR5cGUsXG4gICAgZXhwZWN0ZWQ6IGlzc3VlLmNvbnRleHQuZXhwZWN0cyxcbiAgICByZWNlaXZlZCxcbiAgICBtZXNzYWdlOiBgSW52YWxpZCAke2lzc3VlLmxhYmVsfTogJHtpc3N1ZS5jb250ZXh0LmV4cGVjdHMgPyBgRXhwZWN0ZWQgJHtpc3N1ZS5jb250ZXh0LmV4cGVjdHN9IGJ1dCByYCA6IFwiUlwifWVjZWl2ZWQgJHtyZWNlaXZlZH1gLFxuICAgIGlucHV0OiBpc3N1ZS5pbnB1dCxcbiAgICByZXF1aXJlbWVudDogaXNzdWUuY29udGV4dC5yZXF1aXJlbWVudCxcbiAgICBwYXRoOiBpc3N1ZS5wYXRoLFxuICAgIGxhbmc6IGNvbmZpZz8ubGFuZyxcbiAgICBhYm9ydEVhcmx5OiBjb25maWc/LmFib3J0RWFybHksXG4gICAgYWJvcnRQaXBlRWFybHk6IGNvbmZpZz8uYWJvcnRQaXBlRWFybHksXG4gICAgc2tpcFBpcGU6IGNvbmZpZz8uc2tpcFBpcGVcbiAgfTtcbiAgc2NoZW1hSXNzdWUyLm1lc3NhZ2UgPSBpMThuKFxuICAgIGZhbHNlLFxuICAgIGlzc3VlLmNvbnRleHQsXG4gICAgaXNzdWUucmVmZXJlbmNlLFxuICAgIGNvbmZpZyxcbiAgICBzY2hlbWFJc3N1ZTJcbiAgKTtcbiAgcmV0dXJuIHNjaGVtYUlzc3VlMjtcbn1cblxuLy8gc3JjL3V0aWxzL3BpcGVSZXN1bHQvcGlwZVJlc3VsdC50c1xuZnVuY3Rpb24gcGlwZVJlc3VsdChjb250ZXh0LCBpbnB1dCwgY29uZmlnLCBpc3N1ZXMpIHtcbiAgaWYgKGNvbnRleHQucGlwZSAmJiAhY29uZmlnPy5za2lwUGlwZSkge1xuICAgIGZvciAoY29uc3QgYWN0aW9uIG9mIGNvbnRleHQucGlwZSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYWN0aW9uLl9wYXJzZShpbnB1dCk7XG4gICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbklzc3VlMiBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgY29uc3Qgc2NoZW1hSXNzdWUyID0gcGlwZUlzc3VlKGNvbnRleHQsIGNvbmZpZywgYWN0aW9uSXNzdWUyKTtcbiAgICAgICAgICBpc3N1ZXMgPyBpc3N1ZXMucHVzaChzY2hlbWFJc3N1ZTIpIDogaXNzdWVzID0gW3NjaGVtYUlzc3VlMl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZz8uYWJvcnRFYXJseSB8fCBjb25maWc/LmFib3J0UGlwZUVhcmx5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0ID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNjaGVtYVJlc3VsdCh0cnVlLCBpbnB1dCwgaXNzdWVzKTtcbn1cblxuLy8gc3JjL3V0aWxzL3BpcGVSZXN1bHQvcGlwZVJlc3VsdEFzeW5jLnRzXG5hc3luYyBmdW5jdGlvbiBwaXBlUmVzdWx0QXN5bmMoY29udGV4dCwgaW5wdXQsIGNvbmZpZywgaXNzdWVzKSB7XG4gIGlmIChjb250ZXh0LnBpcGUgJiYgIWNvbmZpZz8uc2tpcFBpcGUpIHtcbiAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBjb250ZXh0LnBpcGUpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFjdGlvbi5fcGFyc2UoaW5wdXQpO1xuICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBhY3Rpb25Jc3N1ZTIgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgIGNvbnN0IHNjaGVtYUlzc3VlMiA9IHBpcGVJc3N1ZShjb250ZXh0LCBjb25maWcsIGFjdGlvbklzc3VlMik7XG4gICAgICAgICAgaXNzdWVzID8gaXNzdWVzLnB1c2goc2NoZW1hSXNzdWUyKSA6IGlzc3VlcyA9IFtzY2hlbWFJc3N1ZTJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkgfHwgY29uZmlnPy5hYm9ydFBpcGVFYXJseSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dCA9IHJlc3VsdC5vdXRwdXQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQsIGlzc3Vlcyk7XG59XG5cbi8vIHNyYy91dGlscy9yZXN0QW5kRGVmYXVsdEFyZ3MvcmVzdEFuZERlZmF1bHRBcmdzLnRzXG5mdW5jdGlvbiByZXN0QW5kRGVmYXVsdEFyZ3MoYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAoIWFyZzEgfHwgdHlwZW9mIGFyZzEgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICBjb25zdCBbZXJyb3IyLCBwaXBlMl0gPSBkZWZhdWx0QXJncyhhcmcyLCBhcmczKTtcbiAgICByZXR1cm4gW2FyZzEsIGVycm9yMiwgcGlwZTJdO1xuICB9XG4gIGNvbnN0IFtlcnJvciwgcGlwZV0gPSBkZWZhdWx0QXJncyhcbiAgICBhcmcxLFxuICAgIGFyZzJcbiAgKTtcbiAgcmV0dXJuIFt2b2lkIDAsIGVycm9yLCBwaXBlXTtcbn1cblxuLy8gc3JjL3V0aWxzL3NjaGVtYUlzc3VlL3NjaGVtYUlzc3VlLnRzXG5mdW5jdGlvbiBzY2hlbWFJc3N1ZShjb250ZXh0LCByZWZlcmVuY2UsIGlucHV0LCBjb25maWcsIG90aGVyKSB7XG4gIGNvbnN0IHJlY2VpdmVkID0gc3RyaW5naWZ5KGlucHV0KTtcbiAgY29uc3QgZXhwZWN0ZWQgPSBvdGhlcj8uZXhwZWN0ZWQgPz8gY29udGV4dC5leHBlY3RzO1xuICBjb25zdCBpc3N1ZSA9IHtcbiAgICByZWFzb246IG90aGVyPy5yZWFzb24gPz8gXCJ0eXBlXCIsXG4gICAgY29udGV4dDogY29udGV4dC50eXBlLFxuICAgIGV4cGVjdGVkLFxuICAgIHJlY2VpdmVkLFxuICAgIG1lc3NhZ2U6IGBJbnZhbGlkIHR5cGU6IEV4cGVjdGVkICR7ZXhwZWN0ZWR9IGJ1dCByZWNlaXZlZCAke3JlY2VpdmVkfWAsXG4gICAgaW5wdXQsXG4gICAgcGF0aDogb3RoZXI/LnBhdGgsXG4gICAgaXNzdWVzOiBvdGhlcj8uaXNzdWVzLFxuICAgIGxhbmc6IGNvbmZpZz8ubGFuZyxcbiAgICBhYm9ydEVhcmx5OiBjb25maWc/LmFib3J0RWFybHksXG4gICAgYWJvcnRQaXBlRWFybHk6IGNvbmZpZz8uYWJvcnRQaXBlRWFybHksXG4gICAgc2tpcFBpcGU6IGNvbmZpZz8uc2tpcFBpcGVcbiAgfTtcbiAgaXNzdWUubWVzc2FnZSA9IGkxOG4odHJ1ZSwgY29udGV4dCwgcmVmZXJlbmNlLCBjb25maWcsIGlzc3VlKTtcbiAgcmV0dXJuIHsgdHlwZWQ6IGZhbHNlLCBvdXRwdXQ6IGlucHV0LCBpc3N1ZXM6IFtpc3N1ZV0gfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZ2V0RmFsbGJhY2svZ2V0RmFsbGJhY2sudHNcbmZ1bmN0aW9uIGdldEZhbGxiYWNrKHNjaGVtYSwgaW5mbykge1xuICByZXR1cm4gdHlwZW9mIHNjaGVtYS5mYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiID8gc2NoZW1hLmZhbGxiYWNrKGluZm8pIDogc2NoZW1hLmZhbGxiYWNrO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXRGYWxsYmFjay9nZXRGYWxsYmFja0FzeW5jLnRzXG5hc3luYyBmdW5jdGlvbiBnZXRGYWxsYmFja0FzeW5jKHNjaGVtYSwgaW5mbykge1xuICByZXR1cm4gdHlwZW9mIHNjaGVtYS5mYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiID8gYXdhaXQgc2NoZW1hLmZhbGxiYWNrKGluZm8pIDogc2NoZW1hLmZhbGxiYWNrO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9mYWxsYmFjay9mYWxsYmFjay50c1xuZnVuY3Rpb24gZmFsbGJhY2soc2NoZW1hLCBmYWxsYmFjazIpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgZmFsbGJhY2s6IGZhbGxiYWNrMixcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICAgIHJldHVybiByZXN1bHQuaXNzdWVzID8gc2NoZW1hUmVzdWx0KFxuICAgICAgICB0cnVlLFxuICAgICAgICBnZXRGYWxsYmFjayh0aGlzLCB7IGlucHV0LCBpc3N1ZXM6IHJlc3VsdC5pc3N1ZXMgfSlcbiAgICAgICkgOiByZXN1bHQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9mYWxsYmFjay9mYWxsYmFja0FzeW5jLnRzXG5mdW5jdGlvbiBmYWxsYmFja0FzeW5jKHNjaGVtYSwgZmFsbGJhY2syKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIGZhbGxiYWNrOiBmYWxsYmFjazIsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYS5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgICByZXR1cm4gcmVzdWx0Lmlzc3VlcyA/IHNjaGVtYVJlc3VsdChcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgYXdhaXQgZ2V0RmFsbGJhY2tBc3luYyh0aGlzLCB7IGlucHV0LCBpc3N1ZXM6IHJlc3VsdC5pc3N1ZXMgfSlcbiAgICAgICkgOiByZXN1bHQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9mb3J3YXJkL2ZvcndhcmQudHNcbmZ1bmN0aW9uIGZvcndhcmQodmFsaWRhdGlvbiwgcGF0aExpc3QpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi52YWxpZGF0aW9uLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGlvbi5fcGFyc2UoaW5wdXQpO1xuICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgbGV0IHBhdGhJbnB1dCA9IGlucHV0O1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHBhdGhMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoVmFsdWUgPSBwYXRoSW5wdXRba2V5XTtcbiAgICAgICAgICAgIGlzc3VlLmlucHV0ID0gcGF0aFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidW5rbm93blwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQ6IHBhdGhJbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogcGF0aFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaXNzdWUucGF0aCA/IGlzc3VlLnBhdGgucHVzaChwYXRoSXRlbSkgOiBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgIGlmICghcGF0aFZhbHVlKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aElucHV0ID0gcGF0aFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL2ZvcndhcmQvZm9yd2FyZEFzeW5jLnRzXG5mdW5jdGlvbiBmb3J3YXJkQXN5bmModmFsaWRhdGlvbiwgcGF0aExpc3QpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi52YWxpZGF0aW9uLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGlvbi5fcGFyc2UoaW5wdXQpO1xuICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgbGV0IHBhdGhJbnB1dCA9IGlucHV0O1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHBhdGhMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoVmFsdWUgPSBwYXRoSW5wdXRba2V5XTtcbiAgICAgICAgICAgIGlzc3VlLmlucHV0ID0gcGF0aFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidW5rbm93blwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQ6IHBhdGhJbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogcGF0aFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaXNzdWUucGF0aCA/IGlzc3VlLnBhdGgucHVzaChwYXRoSXRlbSkgOiBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgIGlmICghcGF0aFZhbHVlKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aElucHV0ID0gcGF0aFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldERlZmF1bHQvZ2V0RGVmYXVsdC50c1xuZnVuY3Rpb24gZ2V0RGVmYXVsdChzY2hlbWEpIHtcbiAgcmV0dXJuIHR5cGVvZiBzY2hlbWEuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiID8gc2NoZW1hLmRlZmF1bHQoKSA6IHNjaGVtYS5kZWZhdWx0O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXREZWZhdWx0L2dldERlZmF1bHRBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0RGVmYXVsdEFzeW5jKHNjaGVtYSkge1xuICByZXR1cm4gdHlwZW9mIHNjaGVtYS5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgPyBhd2FpdCBzY2hlbWEuZGVmYXVsdCgpIDogc2NoZW1hLmRlZmF1bHQ7XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldERlZmF1bHRzL2dldERlZmF1bHRzLnRzXG5mdW5jdGlvbiBnZXREZWZhdWx0cyhzY2hlbWEpIHtcbiAgaWYgKHNjaGVtYS5kZWZhdWx0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gZ2V0RGVmYXVsdChzY2hlbWEpO1xuICB9XG4gIGlmIChpc09mVHlwZShcIm9iamVjdFwiLCBzY2hlbWEpKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5lbnRyaWVzKS5tYXAoKFtrZXksIHZhbHVlMl0pID0+IFtcbiAgICAgICAga2V5LFxuICAgICAgICBnZXREZWZhdWx0cyh2YWx1ZTIpXG4gICAgICBdKVxuICAgICk7XG4gIH1cbiAgaWYgKGlzT2ZUeXBlKFwidHVwbGVcIiwgc2NoZW1hKSkge1xuICAgIHJldHVybiBzY2hlbWEuaXRlbXMubWFwKGdldERlZmF1bHRzKTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXREZWZhdWx0cy9nZXREZWZhdWx0c0FzeW5jLnRzXG5hc3luYyBmdW5jdGlvbiBnZXREZWZhdWx0c0FzeW5jKHNjaGVtYSkge1xuICBpZiAoc2NoZW1hLmRlZmF1bHQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBnZXREZWZhdWx0QXN5bmMoc2NoZW1hKTtcbiAgfVxuICBpZiAoaXNPZlR5cGUoXCJvYmplY3RcIiwgc2NoZW1hKSkge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLmVudHJpZXMpLm1hcChhc3luYyAoW2tleSwgdmFsdWUyXSkgPT4gW1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBhd2FpdCBnZXREZWZhdWx0c0FzeW5jKHZhbHVlMilcbiAgICAgICAgXSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGlmIChpc09mVHlwZShcInR1cGxlXCIsIHNjaGVtYSkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICBzY2hlbWEuaXRlbXMubWFwKGdldERlZmF1bHRzQXN5bmMpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXRGYWxsYmFja3MvZ2V0RmFsbGJhY2tzLnRzXG5mdW5jdGlvbiBnZXRGYWxsYmFja3Moc2NoZW1hKSB7XG4gIGlmIChzY2hlbWEuZmFsbGJhY2sgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBnZXRGYWxsYmFjayhzY2hlbWEpO1xuICB9XG4gIGlmIChpc09mVHlwZShcIm9iamVjdFwiLCBzY2hlbWEpKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5lbnRyaWVzKS5tYXAoKFtrZXksIHZhbHVlMl0pID0+IFtcbiAgICAgICAga2V5LFxuICAgICAgICBnZXRGYWxsYmFja3ModmFsdWUyKVxuICAgICAgXSlcbiAgICApO1xuICB9XG4gIGlmIChpc09mVHlwZShcInR1cGxlXCIsIHNjaGVtYSkpIHtcbiAgICByZXR1cm4gc2NoZW1hLml0ZW1zLm1hcChnZXRGYWxsYmFja3MpO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldEZhbGxiYWNrcy9nZXRGYWxsYmFja3NBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0RmFsbGJhY2tzQXN5bmMoc2NoZW1hKSB7XG4gIGlmIChzY2hlbWEuZmFsbGJhY2sgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBnZXRGYWxsYmFja0FzeW5jKHNjaGVtYSk7XG4gIH1cbiAgaWYgKGlzT2ZUeXBlKFwib2JqZWN0XCIsIHNjaGVtYSkpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5lbnRyaWVzKS5tYXAoYXN5bmMgKFtrZXksIHZhbHVlMl0pID0+IFtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgYXdhaXQgZ2V0RmFsbGJhY2tzQXN5bmModmFsdWUyKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgaWYgKGlzT2ZUeXBlKFwidHVwbGVcIiwgc2NoZW1hKSkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIHNjaGVtYS5pdGVtcy5tYXAoZ2V0RmFsbGJhY2tzQXN5bmMpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9pcy9pcy50c1xuZnVuY3Rpb24gaXMoc2NoZW1hLCBpbnB1dCwgY29uZmlnKSB7XG4gIHJldHVybiAhc2NoZW1hLl9wYXJzZShpbnB1dCwge1xuICAgIGFib3J0RWFybHk6IHRydWUsXG4gICAgc2tpcFBpcGU6IGdldEdsb2JhbENvbmZpZyhjb25maWcpPy5za2lwUGlwZVxuICB9KS5pc3N1ZXM7XG59XG5cbi8vIHNyYy9zY2hlbWFzL2FueS9hbnkudHNcbmZ1bmN0aW9uIGFueShwaXBlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJhbnlcIixcbiAgICBleHBlY3RzOiBcImFueVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2FueS9hbnlBc3luYy50c1xuZnVuY3Rpb24gYW55QXN5bmMocGlwZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYW55XCIsXG4gICAgZXhwZWN0czogXCJhbnlcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICByZXR1cm4gcGlwZVJlc3VsdEFzeW5jKHRoaXMsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYXJyYXkvYXJyYXkudHNcbmZ1bmN0aW9uIGFycmF5KGl0ZW0sIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgaXRlbSxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBsZXQgdHlwZWQgPSB0cnVlO1xuICAgICAgICBsZXQgaXNzdWVzO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgaW5wdXQubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5pdGVtLl9wYXJzZSh2YWx1ZTIsIGNvbmZpZyk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQucHVzaChyZXN1bHQub3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZWQpIHtcbiAgICAgICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBvdXRwdXQsIGNvbmZpZywgaXNzdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KGZhbHNlLCBvdXRwdXQsIGlzc3Vlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgYXJyYXksIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYXJyYXkvYXJyYXlBc3luYy50c1xuZnVuY3Rpb24gYXJyYXlBc3luYyhpdGVtLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzIsIGFyZzMpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBleHBlY3RzOiBcIkFycmF5XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgaXRlbSxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBsZXQgdHlwZWQgPSB0cnVlO1xuICAgICAgICBsZXQgaXNzdWVzO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgaW5wdXQubWFwKGFzeW5jICh2YWx1ZTIsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKCEoY29uZmlnPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5pdGVtLl9wYXJzZSh2YWx1ZTIsIGNvbmZpZyk7XG4gICAgICAgICAgICAgIGlmICghKGNvbmZpZz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICAgIGlmICh0eXBlZCkge1xuICAgICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmMoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgaXNzdWVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KGZhbHNlLCBvdXRwdXQsIGlzc3Vlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgYXJyYXlBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9iaWdpbnQvYmlnaW50LnRzXG5mdW5jdGlvbiBiaWdpbnQoYXJnMSwgYXJnMikge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgIGV4cGVjdHM6IFwiYmlnaW50XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBiaWdpbnQsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYmlnaW50L2JpZ2ludEFzeW5jLnRzXG5mdW5jdGlvbiBiaWdpbnRBc3luYyhhcmcxLCBhcmcyKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzEsIGFyZzIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgZXhwZWN0czogXCJiaWdpbnRcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBiaWdpbnRBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ibG9iL2Jsb2IudHNcbmZ1bmN0aW9uIGJsb2IoYXJnMSwgYXJnMikge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImJsb2JcIixcbiAgICBleHBlY3RzOiBcIkJsb2JcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0KHRoaXMsIGlucHV0LCBjb25maWcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIGJsb2IsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYmxvYi9ibG9iQXN5bmMudHNcbmZ1bmN0aW9uIGJsb2JBc3luYyhhcmcxLCBhcmcyKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzEsIGFyZzIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYmxvYlwiLFxuICAgIGV4cGVjdHM6IFwiQmxvYlwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdEFzeW5jKHRoaXMsIGlucHV0LCBjb25maWcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIGJsb2JBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ib29sZWFuL2Jvb2xlYW4udHNcbmZ1bmN0aW9uIGJvb2xlYW4oYXJnMSwgYXJnMikge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBleHBlY3RzOiBcImJvb2xlYW5cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBib29sZWFuLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2Jvb2xlYW4vYm9vbGVhbkFzeW5jLnRzXG5mdW5jdGlvbiBib29sZWFuQXN5bmMoYXJnMSwgYXJnMikge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBleHBlY3RzOiBcImJvb2xlYW5cIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmModGhpcywgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgYm9vbGVhbkFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2RhdGUvZGF0ZS50c1xuZnVuY3Rpb24gZGF0ZShhcmcxLCBhcmcyKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzEsIGFyZzIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZGF0ZVwiLFxuICAgIGV4cGVjdHM6IFwiRGF0ZVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKGlucHV0LmdldFRpbWUoKSkpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHQodGhpcywgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgZGF0ZSwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9kYXRlL2RhdGVBc3luYy50c1xuZnVuY3Rpb24gZGF0ZUFzeW5jKGFyZzEsIGFyZzIpIHtcbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMSwgYXJnMik7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJkYXRlXCIsXG4gICAgZXhwZWN0czogXCJEYXRlXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTihpbnB1dC5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmModGhpcywgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgZGF0ZUFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2VudW0vZW51bS50c1xuZnVuY3Rpb24gZW51bV8oZW51bV9fLCBtZXNzYWdlKSB7XG4gIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoZW51bV9fKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICBleHBlY3RzOiB2YWx1ZXMubWFwKHN0cmluZ2lmeSkuam9pbihcIiB8IFwiKSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZW51bTogZW51bV9fLFxuICAgIG1lc3NhZ2UsXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmICh2YWx1ZXMuaW5jbHVkZXMoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIGVudW1fLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2VudW0vZW51bUFzeW5jLnRzXG5mdW5jdGlvbiBlbnVtQXN5bmMoZW51bV8yLCBtZXNzYWdlKSB7XG4gIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoZW51bV8yKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICBleHBlY3RzOiB2YWx1ZXMubWFwKHN0cmluZ2lmeSkuam9pbihcIiB8IFwiKSxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBlbnVtOiBlbnVtXzIsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKHZhbHVlcy5pbmNsdWRlcyhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgZW51bUFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2luc3RhbmNlL2luc3RhbmNlLnRzXG5mdW5jdGlvbiBpbnN0YW5jZShjbGFzc18sIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJpbnN0YW5jZVwiLFxuICAgIGV4cGVjdHM6IGNsYXNzXy5uYW1lLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBjbGFzczogY2xhc3NfLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgdGhpcy5jbGFzcykge1xuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBpbnN0YW5jZSwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9pbnN0YW5jZS9pbnN0YW5jZUFzeW5jLnRzXG5mdW5jdGlvbiBpbnN0YW5jZUFzeW5jKGNsYXNzXywgYXJnMiwgYXJnMykge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcyLCBhcmczKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImluc3RhbmNlXCIsXG4gICAgZXhwZWN0czogY2xhc3NfLm5hbWUsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgY2xhc3M6IGNsYXNzXyxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIHRoaXMuY2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBpbnN0YW5jZUFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2ludGVyc2VjdC91dGlscy9tZXJnZU91dHB1dHMvbWVyZ2VPdXRwdXRzLnRzXG5mdW5jdGlvbiBtZXJnZU91dHB1dHMob3V0cHV0MSwgb3V0cHV0Mikge1xuICBpZiAodHlwZW9mIG91dHB1dDEgPT09IHR5cGVvZiBvdXRwdXQyKSB7XG4gICAgaWYgKG91dHB1dDEgPT09IG91dHB1dDIgfHwgb3V0cHV0MSBpbnN0YW5jZW9mIERhdGUgJiYgb3V0cHV0MiBpbnN0YW5jZW9mIERhdGUgJiYgK291dHB1dDEgPT09ICtvdXRwdXQyKSB7XG4gICAgICByZXR1cm4geyBvdXRwdXQ6IG91dHB1dDEgfTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3V0cHV0MSkgJiYgQXJyYXkuaXNBcnJheShvdXRwdXQyKSkge1xuICAgICAgaWYgKG91dHB1dDEubGVuZ3RoID09PSBvdXRwdXQyLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBhcnJheTIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG91dHB1dDEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWVyZ2VPdXRwdXRzKG91dHB1dDFbaW5kZXhdLCBvdXRwdXQyW2luZGV4XSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pbnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBhcnJheTIucHVzaChyZXN1bHQub3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBvdXRwdXQ6IGFycmF5MiB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgaW52YWxpZDogdHJ1ZSB9O1xuICAgIH1cbiAgICBpZiAob3V0cHV0MSAmJiBvdXRwdXQyICYmIG91dHB1dDEuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBvdXRwdXQyLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgIGNvbnN0IG9iamVjdDIgPSB7IC4uLm91dHB1dDEsIC4uLm91dHB1dDIgfTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG91dHB1dDEpIHtcbiAgICAgICAgaWYgKGtleSBpbiBvdXRwdXQyKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWVyZ2VPdXRwdXRzKG91dHB1dDFba2V5XSwgb3V0cHV0MltrZXldKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmludmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdDJba2V5XSA9IHJlc3VsdC5vdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG91dHB1dDogb2JqZWN0MiB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBpbnZhbGlkOiB0cnVlIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2ludGVyc2VjdC9pbnRlcnNlY3QudHNcbmZ1bmN0aW9uIGludGVyc2VjdChvcHRpb25zLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzIsIGFyZzMpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaW50ZXJzZWN0XCIsXG4gICAgZXhwZWN0czogWy4uLm5ldyBTZXQob3B0aW9ucy5tYXAoKG9wdGlvbikgPT4gb3B0aW9uLmV4cGVjdHMpKV0uam9pbihcIiAmIFwiKSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGxldCB0eXBlZCA9IHRydWU7XG4gICAgICBsZXQgaXNzdWVzO1xuICAgICAgbGV0IG91dHB1dDtcbiAgICAgIGNvbnN0IG91dHB1dHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHRoaXMub3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3BhcnNlKGlucHV0LCBjb25maWcpO1xuICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgIGlmIChpc3N1ZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpc3N1ZXMucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzc3VlcyA9IHJlc3VsdC5pc3N1ZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dHMucHVzaChyZXN1bHQub3V0cHV0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlZCkge1xuICAgICAgICBvdXRwdXQgPSBvdXRwdXRzWzBdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgb3V0cHV0cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtZXJnZU91dHB1dHMob3V0cHV0LCBvdXRwdXRzW2luZGV4XSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pbnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgaW50ZXJzZWN0LCBpbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0ID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBvdXRwdXQsIGNvbmZpZywgaXNzdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2ludGVyc2VjdC9pbnRlcnNlY3RBc3luYy50c1xuZnVuY3Rpb24gaW50ZXJzZWN0QXN5bmMob3B0aW9ucywgYXJnMiwgYXJnMykge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcyLCBhcmczKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImludGVyc2VjdFwiLFxuICAgIGV4cGVjdHM6IFsuLi5uZXcgU2V0KG9wdGlvbnMubWFwKChvcHRpb24pID0+IG9wdGlvbi5leHBlY3RzKSldLmpvaW4oXCIgJiBcIiksXG4gICAgYXN5bmM6IHRydWUsXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGxldCB0eXBlZCA9IHRydWU7XG4gICAgICBsZXQgaXNzdWVzO1xuICAgICAgbGV0IG91dHB1dDtcbiAgICAgIGNvbnN0IG91dHB1dHMgPSBbXTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICB0aGlzLm9wdGlvbnMubWFwKGFzeW5jIChzY2hlbWEpID0+IHtcbiAgICAgICAgICBpZiAoIShjb25maWc/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2NoZW1hLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmICghKGNvbmZpZz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3Vlcy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIHRocm93IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghcmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gocmVzdWx0Lm91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgIGlmICh0eXBlZCkge1xuICAgICAgICBvdXRwdXQgPSBvdXRwdXRzWzBdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgb3V0cHV0cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBtZXJnZU91dHB1dHMob3V0cHV0LCBvdXRwdXRzW2luZGV4XSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pbnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgaW50ZXJzZWN0QXN5bmMsIGlucHV0LCBjb25maWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQgPSByZXN1bHQub3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmModGhpcywgb3V0cHV0LCBjb25maWcsIGlzc3Vlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KGZhbHNlLCBvdXRwdXQsIGlzc3Vlcyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9sYXp5L2xhenkudHNcbmZ1bmN0aW9uIGxhenkoZ2V0dGVyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJsYXp5XCIsXG4gICAgZXhwZWN0czogXCJ1bmtub3duXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGdldHRlcixcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0dGVyKGlucHV0KS5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9sYXp5L2xhenlBc3luYy50c1xuZnVuY3Rpb24gbGF6eUFzeW5jKGdldHRlcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibGF6eVwiLFxuICAgIGV4cGVjdHM6IFwidW5rbm93blwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGdldHRlcixcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldHRlcihpbnB1dCkpLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2xpdGVyYWwvbGl0ZXJhbC50c1xuZnVuY3Rpb24gbGl0ZXJhbChsaXRlcmFsXywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibGl0ZXJhbFwiLFxuICAgIGV4cGVjdHM6IHN0cmluZ2lmeShsaXRlcmFsXyksXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGxpdGVyYWw6IGxpdGVyYWxfLFxuICAgIG1lc3NhZ2UsXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gdGhpcy5saXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIGxpdGVyYWwsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbGl0ZXJhbC9saXRlcmFsQXN5bmMudHNcbmZ1bmN0aW9uIGxpdGVyYWxBc3luYyhsaXRlcmFsMiwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibGl0ZXJhbFwiLFxuICAgIGV4cGVjdHM6IHN0cmluZ2lmeShsaXRlcmFsMiksXG4gICAgYXN5bmM6IHRydWUsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbDIsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0ID09PSB0aGlzLmxpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgbGl0ZXJhbEFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL21hcC9tYXAudHNcbmZ1bmN0aW9uIG1hcChrZXksIHZhbHVlMiwgYXJnMywgYXJnNCkge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmczLCBhcmc0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1hcFwiLFxuICAgIGV4cGVjdHM6IFwiTWFwXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGtleSxcbiAgICB2YWx1ZTogdmFsdWUyLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGxldCB0eXBlZCA9IHRydWU7XG4gICAgICAgIGxldCBpc3N1ZXM7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2lucHV0S2V5LCBpbnB1dFZhbHVlXSBvZiBpbnB1dC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBsZXQgcGF0aEl0ZW07XG4gICAgICAgICAgY29uc3Qga2V5UmVzdWx0ID0gdGhpcy5rZXkuX3BhcnNlKGlucHV0S2V5LCBjb25maWcpO1xuICAgICAgICAgIGlmIChrZXlSZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJtYXBcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcImtleVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiBpbnB1dEtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IGlucHV0VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGtleVJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICBpc3N1ZXMgPSBrZXlSZXN1bHQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdmFsdWVSZXN1bHQgPSB0aGlzLnZhbHVlLl9wYXJzZShpbnB1dFZhbHVlLCBjb25maWcpO1xuICAgICAgICAgIGlmICh2YWx1ZVJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIHBhdGhJdGVtID0gcGF0aEl0ZW0gPz8ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm1hcFwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZVJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICBpc3N1ZXMgPSB2YWx1ZVJlc3VsdC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWtleVJlc3VsdC50eXBlZCB8fCAhdmFsdWVSZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5zZXQoa2V5UmVzdWx0Lm91dHB1dCwgdmFsdWVSZXN1bHQub3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZWQpIHtcbiAgICAgICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBvdXRwdXQsIGNvbmZpZywgaXNzdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KGZhbHNlLCBvdXRwdXQsIGlzc3Vlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgbWFwLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL21hcC9tYXBBc3luYy50c1xuZnVuY3Rpb24gbWFwQXN5bmMoa2V5LCB2YWx1ZTIsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMywgYXJnNCk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJtYXBcIixcbiAgICBleHBlY3RzOiBcIk1hcFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGtleSxcbiAgICB2YWx1ZTogdmFsdWUyLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGxldCB0eXBlZCA9IHRydWU7XG4gICAgICAgIGxldCBpc3N1ZXM7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIEFycmF5LmZyb20oaW5wdXQuZW50cmllcygpKS5tYXAoYXN5bmMgKFtpbnB1dEtleSwgaW5wdXRWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGxldCBwYXRoSXRlbTtcbiAgICAgICAgICAgIGNvbnN0IFtrZXlSZXN1bHQsIHZhbHVlUmVzdWx0XSA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgeyBzY2hlbWE6IHRoaXMua2V5LCB2YWx1ZTogaW5wdXRLZXksIG9yaWdpbjogXCJrZXlcIiB9LFxuICAgICAgICAgICAgICAgIHsgc2NoZW1hOiB0aGlzLnZhbHVlLCB2YWx1ZTogaW5wdXRWYWx1ZSwgb3JpZ2luOiBcInZhbHVlXCIgfVxuICAgICAgICAgICAgICBdLm1hcChhc3luYyAoeyBzY2hlbWEsIHZhbHVlOiB2YWx1ZTMsIG9yaWdpbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEoY29uZmlnPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYS5fcGFyc2UodmFsdWUzLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoY29uZmlnPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXRoSXRlbSA9IHBhdGhJdGVtID8/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibWFwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApLmNhdGNoKCgpID0+IFtdKTtcbiAgICAgICAgICAgIGlmICgha2V5UmVzdWx0Py50eXBlZCB8fCAhdmFsdWVSZXN1bHQ/LnR5cGVkKSB7XG4gICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5UmVzdWx0ICYmIHZhbHVlUmVzdWx0KSB7XG4gICAgICAgICAgICAgIG91dHB1dC5zZXQoa2V5UmVzdWx0Lm91dHB1dCwgdmFsdWVSZXN1bHQub3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBpZiAodHlwZWQpIHtcbiAgICAgICAgICByZXR1cm4gcGlwZVJlc3VsdEFzeW5jKHRoaXMsIG91dHB1dCwgY29uZmlnLCBpc3N1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBtYXBBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9uYW4vbmFuLnRzXG5mdW5jdGlvbiBuYW4obWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibmFuXCIsXG4gICAgZXhwZWN0czogXCJOYU5cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKE51bWJlci5pc05hTihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgbmFuLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25hbi9uYW5Bc3luYy50c1xuZnVuY3Rpb24gbmFuQXN5bmMobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibmFuXCIsXG4gICAgZXhwZWN0czogXCJOYU5cIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBuYW5Bc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9uZXZlci9uZXZlci50c1xuZnVuY3Rpb24gbmV2ZXIobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibmV2ZXJcIixcbiAgICBleHBlY3RzOiBcIm5ldmVyXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBuZXZlciwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9uZXZlci9uZXZlckFzeW5jLnRzXG5mdW5jdGlvbiBuZXZlckFzeW5jKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm5ldmVyXCIsXG4gICAgZXhwZWN0czogXCJuZXZlclwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBuZXZlckFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk51bGxhYmxlL25vbk51bGxhYmxlLnRzXG5mdW5jdGlvbiBub25OdWxsYWJsZSh3cmFwcGVkLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJub25fbnVsbGFibGVcIixcbiAgICBleHBlY3RzOiBcIiFudWxsXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHdyYXBwZWQsXG4gICAgbWVzc2FnZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBub25OdWxsYWJsZSwgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk51bGxhYmxlL25vbk51bGxhYmxlQXN5bmMudHNcbmZ1bmN0aW9uIG5vbk51bGxhYmxlQXN5bmMod3JhcHBlZCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibm9uX251bGxhYmxlXCIsXG4gICAgZXhwZWN0czogXCIhbnVsbFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBub25OdWxsYWJsZUFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWQuX3BhcnNlKGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbm9uTnVsbGlzaC9ub25OdWxsaXNoLnRzXG5mdW5jdGlvbiBub25OdWxsaXNoKHdyYXBwZWQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm5vbl9udWxsaXNoXCIsXG4gICAgZXhwZWN0czogXCIhbnVsbCAmICF1bmRlZmluZWRcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgd3JhcHBlZCxcbiAgICBtZXNzYWdlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgbm9uTnVsbGlzaCwgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk51bGxpc2gvbm9uTnVsbGlzaEFzeW5jLnRzXG5mdW5jdGlvbiBub25OdWxsaXNoQXN5bmMod3JhcHBlZCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibm9uX251bGxpc2hcIixcbiAgICBleHBlY3RzOiBcIiFudWxsICYgIXVuZGVmaW5lZFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIG5vbk51bGxpc2hBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk9wdGlvbmFsL25vbk9wdGlvbmFsLnRzXG5mdW5jdGlvbiBub25PcHRpb25hbCh3cmFwcGVkLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJub25fb3B0aW9uYWxcIixcbiAgICBleHBlY3RzOiBcIiF1bmRlZmluZWRcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgd3JhcHBlZCxcbiAgICBtZXNzYWdlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgbm9uT3B0aW9uYWwsIGlucHV0LCBjb25maWcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ub25PcHRpb25hbC9ub25PcHRpb25hbEFzeW5jLnRzXG5mdW5jdGlvbiBub25PcHRpb25hbEFzeW5jKHdyYXBwZWQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm5vbl9vcHRpb25hbFwiLFxuICAgIGV4cGVjdHM6IFwiIXVuZGVmaW5lZFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIG5vbk9wdGlvbmFsQXN5bmMsIGlucHV0LCBjb25maWcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udWxsYWJsZS9udWxsYWJsZS50c1xuZnVuY3Rpb24gbnVsbGFibGUod3JhcHBlZCwgZGVmYXVsdF8pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm51bGxhYmxlXCIsXG4gICAgZXhwZWN0czogYCR7d3JhcHBlZC5leHBlY3RzfSB8IG51bGxgLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB3cmFwcGVkLFxuICAgIGRlZmF1bHQ6IGRlZmF1bHRfLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgb3ZlcnJpZGUgPSBnZXREZWZhdWx0KHRoaXMpO1xuICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gb3ZlcnJpZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL251bGxhYmxlL251bGxhYmxlQXN5bmMudHNcbmZ1bmN0aW9uIG51bGxhYmxlQXN5bmMod3JhcHBlZCwgZGVmYXVsdF8pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm51bGxhYmxlXCIsXG4gICAgZXhwZWN0czogYCR7d3JhcHBlZC5leHBlY3RzfSB8IG51bGxgLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBvdmVycmlkZSA9IGF3YWl0IGdldERlZmF1bHRBc3luYyh0aGlzKTtcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IG92ZXJyaWRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udWxsaXNoL251bGxpc2gudHNcbmZ1bmN0aW9uIG51bGxpc2god3JhcHBlZCwgZGVmYXVsdF8pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm51bGxpc2hcIixcbiAgICBleHBlY3RzOiBgJHt3cmFwcGVkLmV4cGVjdHN9IHwgbnVsbCB8IHVuZGVmaW5lZGAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IG92ZXJyaWRlID0gZ2V0RGVmYXVsdCh0aGlzKTtcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IG92ZXJyaWRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udWxsaXNoL251bGxpc2hBc3luYy50c1xuZnVuY3Rpb24gbnVsbGlzaEFzeW5jKHdyYXBwZWQsIGRlZmF1bHRfKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJudWxsaXNoXCIsXG4gICAgZXhwZWN0czogYCR7d3JhcHBlZC5leHBlY3RzfSB8IG51bGwgfCB1bmRlZmluZWRgLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IG92ZXJyaWRlID0gYXdhaXQgZ2V0RGVmYXVsdEFzeW5jKHRoaXMpO1xuICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gb3ZlcnJpZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL251bGwvbnVsbC50c1xuZnVuY3Rpb24gbnVsbF8obWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibnVsbFwiLFxuICAgIGV4cGVjdHM6IFwibnVsbFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgbnVsbF8sIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbnVsbC9udWxsQXN5bmMudHNcbmZ1bmN0aW9uIG51bGxBc3luYyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJudWxsXCIsXG4gICAgZXhwZWN0czogXCJudWxsXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIG51bGxBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udW1iZXIvbnVtYmVyLnRzXG5mdW5jdGlvbiBudW1iZXIoYXJnMSwgYXJnMikge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGV4cGVjdHM6IFwibnVtYmVyXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0KHRoaXMsIGlucHV0LCBjb25maWcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIG51bWJlciwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udW1iZXIvbnVtYmVyQXN5bmMudHNcbmZ1bmN0aW9uIG51bWJlckFzeW5jKGFyZzEsIGFyZzIpIHtcbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMSwgYXJnMik7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBleHBlY3RzOiBcIm51bWJlclwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmModGhpcywgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgbnVtYmVyQXN5bmMsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvb2JqZWN0L29iamVjdC50c1xuZnVuY3Rpb24gb2JqZWN0KGVudHJpZXMsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW3Jlc3QsIG1lc3NhZ2UsIHBpcGVdID0gcmVzdEFuZERlZmF1bHRBcmdzKGFyZzIsIGFyZzMsIGFyZzQpO1xuICBsZXQgY2FjaGVkRW50cmllcztcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIGV4cGVjdHM6IFwiT2JqZWN0XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGVudHJpZXMsXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY2FjaGVkRW50cmllcyA9IGNhY2hlZEVudHJpZXMgPz8gT2JqZWN0LmVudHJpZXModGhpcy5lbnRyaWVzKTtcbiAgICAgICAgbGV0IHR5cGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGlzc3VlcztcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgc2NoZW1hXSBvZiBjYWNoZWRFbnRyaWVzKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3BhcnNlKHZhbHVlMiwgY29uZmlnKTtcbiAgICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0Lm91dHB1dCAhPT0gdm9pZCAwIHx8IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSByZXN1bHQub3V0cHV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXN0ICYmICEoY29uZmlnPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMuZW50cmllcykpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN0Ll9wYXJzZSh2YWx1ZTIsIGNvbmZpZyk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlcyA9IHJlc3VsdC5pc3N1ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgaXNzdWVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KGZhbHNlLCBvdXRwdXQsIGlzc3Vlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgb2JqZWN0LCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL29iamVjdC9vYmplY3RBc3luYy50c1xuZnVuY3Rpb24gb2JqZWN0QXN5bmMoZW50cmllcywgYXJnMiwgYXJnMywgYXJnNCkge1xuICBjb25zdCBbcmVzdCwgbWVzc2FnZSwgcGlwZV0gPSByZXN0QW5kRGVmYXVsdEFyZ3MoYXJnMiwgYXJnMywgYXJnNCk7XG4gIGxldCBjYWNoZWRFbnRyaWVzO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBlbnRyaWVzLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNhY2hlZEVudHJpZXMgPSBjYWNoZWRFbnRyaWVzID8/IE9iamVjdC5lbnRyaWVzKHRoaXMuZW50cmllcyk7XG4gICAgICAgIGxldCB0eXBlZCA9IHRydWU7XG4gICAgICAgIGxldCBpc3N1ZXM7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBjYWNoZWRFbnRyaWVzLm1hcChhc3luYyAoW2tleSwgc2NoZW1hXSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIShjb25maWc/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2NoZW1hLl9wYXJzZSh2YWx1ZTIsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgaWYgKCEoY29uZmlnPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC50eXBlZCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5vdXRwdXQgIT09IHZvaWQgMCB8fCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSByZXN1bHQub3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLFxuICAgICAgICAgIHRoaXMucmVzdCAmJiBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGlucHV0KS5tYXAoYXN5bmMgKFtrZXksIHZhbHVlMl0pID0+IHtcbiAgICAgICAgICAgICAgaWYgKCEoY29uZmlnPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gdGhpcy5lbnRyaWVzKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXN0Ll9wYXJzZSh2YWx1ZTIsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShjb25maWc/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICBdKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgICAgaWYgKHR5cGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyhcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBpc3N1ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBvYmplY3RBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9vcHRpb25hbC9vcHRpb25hbC50c1xuZnVuY3Rpb24gb3B0aW9uYWwod3JhcHBlZCwgZGVmYXVsdF8pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm9wdGlvbmFsXCIsXG4gICAgZXhwZWN0czogYCR7d3JhcHBlZC5leHBlY3RzfSB8IHVuZGVmaW5lZGAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IG92ZXJyaWRlID0gZ2V0RGVmYXVsdCh0aGlzKTtcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IG92ZXJyaWRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9vcHRpb25hbC9vcHRpb25hbEFzeW5jLnRzXG5mdW5jdGlvbiBvcHRpb25hbEFzeW5jKHdyYXBwZWQsIGRlZmF1bHRfKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgIGV4cGVjdHM6IGAke3dyYXBwZWQuZXhwZWN0c30gfCB1bmRlZmluZWRgLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IG92ZXJyaWRlID0gYXdhaXQgZ2V0RGVmYXVsdEFzeW5jKHRoaXMpO1xuICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gb3ZlcnJpZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3BpY2tsaXN0L3BpY2tsaXN0LnRzXG5mdW5jdGlvbiBwaWNrbGlzdChvcHRpb25zLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJwaWNrbGlzdFwiLFxuICAgIGV4cGVjdHM6IG9wdGlvbnMubWFwKHN0cmluZ2lmeSkuam9pbihcIiB8IFwiKSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmluY2x1ZGVzKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBwaWNrbGlzdCwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9waWNrbGlzdC9waWNrbGlzdEFzeW5jLnRzXG5mdW5jdGlvbiBwaWNrbGlzdEFzeW5jKG9wdGlvbnMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInBpY2tsaXN0XCIsXG4gICAgZXhwZWN0czogb3B0aW9ucy5tYXAoc3RyaW5naWZ5KS5qb2luKFwiIHwgXCIpLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbmNsdWRlcyhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgcGlja2xpc3RBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zdHJpbmcvc3RyaW5nLnRzXG5mdW5jdGlvbiBzdHJpbmcoYXJnMSwgYXJnMikge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcxLCBhcmcyKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIGV4cGVjdHM6IFwic3RyaW5nXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBzdHJpbmcsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc3RyaW5nL3N0cmluZ0FzeW5jLnRzXG5mdW5jdGlvbiBzdHJpbmdBc3luYyhhcmcxLCBhcmcyKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzEsIGFyZzIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgZXhwZWN0czogXCJzdHJpbmdcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBzdHJpbmdBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9yZWNvcmQvdXRpbHMvcmVjb3JkQXJncy9yZWNvcmRBcmdzLnRzXG5mdW5jdGlvbiByZWNvcmRBcmdzKGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgaWYgKHR5cGVvZiBhcmcyID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGFyZzIpKSB7XG4gICAgY29uc3QgW21lc3NhZ2UyLCBwaXBlMl0gPSBkZWZhdWx0QXJncyhhcmczLCBhcmc0KTtcbiAgICByZXR1cm4gW2FyZzEsIGFyZzIsIG1lc3NhZ2UyLCBwaXBlMl07XG4gIH1cbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoXG4gICAgYXJnMixcbiAgICBhcmczXG4gICk7XG4gIHJldHVybiBbc3RyaW5nKCksIGFyZzEsIG1lc3NhZ2UsIHBpcGVdO1xufVxuXG4vLyBzcmMvc2NoZW1hcy9yZWNvcmQvdmFsdWVzLnRzXG52YXIgQkxPQ0tFRF9LRVlTID0gW1wiX19wcm90b19fXCIsIFwicHJvdG90eXBlXCIsIFwiY29uc3RydWN0b3JcIl07XG5cbi8vIHNyYy9zY2hlbWFzL3JlY29yZC9yZWNvcmQudHNcbmZ1bmN0aW9uIHJlY29yZChhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtrZXksIHZhbHVlMiwgbWVzc2FnZSwgcGlwZV0gPSByZWNvcmRBcmdzKGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicmVjb3JkXCIsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAga2V5LFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGxldCB0eXBlZCA9IHRydWU7XG4gICAgICAgIGxldCBpc3N1ZXM7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtpbnB1dEtleSwgaW5wdXRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5wdXQpKSB7XG4gICAgICAgICAgaWYgKCFCTE9DS0VEX0tFWVMuaW5jbHVkZXMoaW5wdXRLZXkpKSB7XG4gICAgICAgICAgICBsZXQgcGF0aEl0ZW07XG4gICAgICAgICAgICBjb25zdCBrZXlSZXN1bHQgPSB0aGlzLmtleS5fcGFyc2UoaW5wdXRLZXksIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoa2V5UmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXk6IGlucHV0S2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2Yga2V5UmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZXMgPSBrZXlSZXN1bHQuaXNzdWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZVJlc3VsdCA9IHRoaXMudmFsdWUuX3BhcnNlKGlucHV0VmFsdWUsIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAodmFsdWVSZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIHBhdGhJdGVtID0gcGF0aEl0ZW0gPz8ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVjb3JkXCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAga2V5OiBpbnB1dEtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlUmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlzc3VlcyA9IHZhbHVlUmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29uZmlnPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrZXlSZXN1bHQudHlwZWQgfHwgIXZhbHVlUmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5UmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIG91dHB1dFtrZXlSZXN1bHQub3V0cHV0XSA9IHZhbHVlUmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgaXNzdWVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KGZhbHNlLCBvdXRwdXQsIGlzc3Vlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgcmVjb3JkLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3JlY29yZC9yZWNvcmRBc3luYy50c1xuZnVuY3Rpb24gcmVjb3JkQXN5bmMoYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICBjb25zdCBba2V5LCB2YWx1ZTIsIG1lc3NhZ2UsIHBpcGVdID0gcmVjb3JkQXJncyhhcmcxLCBhcmcyLCBhcmczLCBhcmc0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgIGV4cGVjdHM6IFwiT2JqZWN0XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAga2V5LFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGxldCB0eXBlZCA9IHRydWU7XG4gICAgICAgIGxldCBpc3N1ZXM7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAvLyBOb3RlOiBgT2JqZWN0LmVudHJpZXMoLi4uKWAgY29udmVydHMgZWFjaCBrZXkgdG8gYSBzdHJpbmdcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhpbnB1dCkubWFwKGFzeW5jIChbaW5wdXRLZXksIGlucHV0VmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUJMT0NLRURfS0VZUy5pbmNsdWRlcyhpbnB1dEtleSkpIHtcbiAgICAgICAgICAgICAgbGV0IHBhdGhJdGVtO1xuICAgICAgICAgICAgICBjb25zdCBba2V5UmVzdWx0LCB2YWx1ZVJlc3VsdF0gPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICB7IHNjaGVtYTogdGhpcy5rZXksIHZhbHVlOiBpbnB1dEtleSwgb3JpZ2luOiBcImtleVwiIH0sXG4gICAgICAgICAgICAgICAgICB7IHNjaGVtYTogdGhpcy52YWx1ZSwgdmFsdWU6IGlucHV0VmFsdWUsIG9yaWdpbjogXCJ2YWx1ZVwiIH1cbiAgICAgICAgICAgICAgICBdLm1hcChhc3luYyAoeyBzY2hlbWEsIHZhbHVlOiB2YWx1ZTMsIG9yaWdpbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoIShjb25maWc/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzY2hlbWEuX3BhcnNlKHZhbHVlMywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoY29uZmlnPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aEl0ZW0gPSBwYXRoSXRlbSA/PyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVjb3JkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICkuY2F0Y2goKCkgPT4gW10pO1xuICAgICAgICAgICAgICBpZiAoIWtleVJlc3VsdD8udHlwZWQgfHwgIXZhbHVlUmVzdWx0Py50eXBlZCkge1xuICAgICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGtleVJlc3VsdD8udHlwZWQgJiYgdmFsdWVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRba2V5UmVzdWx0Lm91dHB1dF0gPSB2YWx1ZVJlc3VsdC5vdXRwdXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBpZiAodHlwZWQpIHtcbiAgICAgICAgICByZXR1cm4gcGlwZVJlc3VsdEFzeW5jKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGlzc3Vlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdChmYWxzZSwgb3V0cHV0LCBpc3N1ZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIHJlY29yZEFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3NldC9zZXQudHNcbmZ1bmN0aW9uIHNldCh2YWx1ZTIsIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzZXRcIixcbiAgICBleHBlY3RzOiBcIlNldFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB2YWx1ZTogdmFsdWUyLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIGxldCBrZXkgPSAwO1xuICAgICAgICBsZXQgdHlwZWQgPSB0cnVlO1xuICAgICAgICBsZXQgaXNzdWVzO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGlucHV0VmFsdWUgb2YgaW5wdXQpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZhbHVlLl9wYXJzZShpbnB1dFZhbHVlLCBjb25maWcpO1xuICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQuYWRkKHJlc3VsdC5vdXRwdXQpO1xuICAgICAgICAgIGtleSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlZCkge1xuICAgICAgICAgIHJldHVybiBwaXBlUmVzdWx0KHRoaXMsIG91dHB1dCwgY29uZmlnLCBpc3N1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBzZXQsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc2V0L3NldEFzeW5jLnRzXG5mdW5jdGlvbiBzZXRBc3luYyh2YWx1ZTIsIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzZXRcIixcbiAgICBleHBlY3RzOiBcIlNldFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgbGV0IHR5cGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGlzc3VlcztcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgQXJyYXkuZnJvbShpbnB1dC52YWx1ZXMoKSkubWFwKGFzeW5jIChpbnB1dFZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghKGNvbmZpZz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudmFsdWUuX3BhcnNlKGlucHV0VmFsdWUsIGNvbmZpZyk7XG4gICAgICAgICAgICAgIGlmICghKGNvbmZpZz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlucHV0VmFsdWVcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC50eXBlZCkge1xuICAgICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0LmFkZChyZXN1bHQub3V0cHV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICAgIGlmICh0eXBlZCkge1xuICAgICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmModGhpcywgb3V0cHV0LCBjb25maWcsIGlzc3Vlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdChmYWxzZSwgb3V0cHV0LCBpc3N1ZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIHNldEFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3NwZWNpYWwvc3BlY2lhbC50c1xuZnVuY3Rpb24gc3BlY2lhbChjaGVjaywgYXJnMiwgYXJnMykge1xuICBjb25zdCBbbWVzc2FnZSwgcGlwZV0gPSBkZWZhdWx0QXJncyhhcmcyLCBhcmczKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNwZWNpYWxcIixcbiAgICBleHBlY3RzOiBcInVua25vd25cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgY2hlY2ssXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAodGhpcy5jaGVjayhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHQodGhpcywgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgc3BlY2lhbCwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zcGVjaWFsL3NwZWNpYWxBc3luYy50c1xuZnVuY3Rpb24gc3BlY2lhbEFzeW5jKGNoZWNrLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzIsIGFyZzMpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3BlY2lhbFwiLFxuICAgIGV4cGVjdHM6IFwidW5rbm93blwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGNoZWNrLFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGF3YWl0IHRoaXMuY2hlY2soaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmModGhpcywgaW5wdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgc3BlY2lhbEFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3N5bWJvbC9zeW1ib2wudHNcbmZ1bmN0aW9uIHN5bWJvbChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzeW1ib2xcIixcbiAgICBleHBlY3RzOiBcInN5bWJvbFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIHN5bWJvbCwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zeW1ib2wvc3ltYm9sQXN5bmMudHNcbmZ1bmN0aW9uIHN5bWJvbEFzeW5jKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN5bWJvbFwiLFxuICAgIGV4cGVjdHM6IFwic3ltYm9sXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICByZXR1cm4gc2NoZW1hUmVzdWx0KHRydWUsIGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCBzeW1ib2xBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy90dXBsZS90dXBsZS50c1xuZnVuY3Rpb24gdHVwbGUoaXRlbXMsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW3Jlc3QsIG1lc3NhZ2UsIHBpcGVdID0gcmVzdEFuZERlZmF1bHRBcmdzKGFyZzIsIGFyZzMsIGFyZzQpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICBleHBlY3RzOiBcIkFycmF5XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGl0ZW1zLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgbGV0IHR5cGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGlzc3VlcztcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGZvciAobGV0IGtleSA9IDA7IGtleSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5pdGVtc1trZXldLl9wYXJzZSh2YWx1ZTIsIGNvbmZpZyk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXRba2V5XSA9IHJlc3VsdC5vdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVzdCAmJiAhKGNvbmZpZz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgZm9yIChsZXQga2V5ID0gdGhpcy5pdGVtcy5sZW5ndGg7IGtleSA8IGlucHV0Lmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc3QuX3BhcnNlKHZhbHVlMiwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZXMgPSByZXN1bHQuaXNzdWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb25maWc/LmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC50eXBlZCkge1xuICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSByZXN1bHQub3V0cHV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZWQpIHtcbiAgICAgICAgICByZXR1cm4gcGlwZVJlc3VsdChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBpc3N1ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCB0dXBsZSwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy90dXBsZS90dXBsZUFzeW5jLnRzXG5mdW5jdGlvbiB0dXBsZUFzeW5jKGl0ZW1zLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlLCBwaXBlXSA9IHJlc3RBbmREZWZhdWx0QXJncyhhcmcyLCBhcmczLCBhcmc0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgZXhwZWN0czogXCJBcnJheVwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGl0ZW1zLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgbGV0IHR5cGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGlzc3VlcztcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAvLyBQYXJzZSBzY2hlbWEgb2YgZWFjaCB0dXBsZSBpdGVtXG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICB0aGlzLml0ZW1zLm1hcChhc3luYyAoc2NoZW1hLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCEoY29uZmlnPy5hYm9ydEVhcmx5ICYmIGlzc3VlcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYS5fcGFyc2UodmFsdWUyLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIGlmICghKGNvbmZpZz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiByZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnPy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC50eXBlZCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSByZXN1bHQub3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLFxuICAgICAgICAgIC8vIElmIG5lY2Vzc2FyeSBwYXJzZSBzY2hlbWEgb2YgZWFjaCByZXN0IGl0ZW1cbiAgICAgICAgICB0aGlzLnJlc3QgJiYgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBpbnB1dC5zbGljZSh0aGlzLml0ZW1zLmxlbmd0aCkubWFwKGFzeW5jICh2YWx1ZTIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgIGlmICghKGNvbmZpZz8uYWJvcnRFYXJseSAmJiBpc3N1ZXMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5pdGVtcy5sZW5ndGggKyBpbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlc3QuX3BhcnNlKHZhbHVlMiwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBpZiAoIShjb25maWc/LmFib3J0RWFybHkgJiYgaXNzdWVzKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGlzc3VlcyA9IHJlc3VsdC5pc3N1ZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZz8uYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0Lm91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICBdKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgICAgaWYgKHR5cGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyhcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBpc3N1ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQoZmFsc2UsIG91dHB1dCwgaXNzdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCB0dXBsZUFzeW5jLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3VuZGVmaW5lZC91bmRlZmluZWQudHNcbmZ1bmN0aW9uIHVuZGVmaW5lZF8obWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidW5kZWZpbmVkXCIsXG4gICAgZXhwZWN0czogXCJ1bmRlZmluZWRcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgdW5kZWZpbmVkXywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy91bmRlZmluZWQvdW5kZWZpbmVkQXN5bmMudHNcbmZ1bmN0aW9uIHVuZGVmaW5lZEFzeW5jKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInVuZGVmaW5lZFwiLFxuICAgIGV4cGVjdHM6IFwidW5kZWZpbmVkXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgaWYgKGlucHV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVJlc3VsdCh0cnVlLCBpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hSXNzdWUodGhpcywgdW5kZWZpbmVkQXN5bmMsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5pb24vdXRpbHMvc3ViaXNzdWVzL3N1Ymlzc3Vlcy50c1xuZnVuY3Rpb24gc3ViaXNzdWVzKHJlc3VsdHMpIHtcbiAgbGV0IGlzc3VlcztcbiAgaWYgKHJlc3VsdHMpIHtcbiAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICBpZiAoaXNzdWVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgcmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgIGlzc3Vlcy5wdXNoKGlzc3VlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNzdWVzID0gcmVzdWx0Lmlzc3VlcztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlzc3Vlcztcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5pb24vdW5pb24udHNcbmZ1bmN0aW9uIHVuaW9uKG9wdGlvbnMsIGFyZzIsIGFyZzMpIHtcbiAgY29uc3QgW21lc3NhZ2UsIHBpcGVdID0gZGVmYXVsdEFyZ3MoYXJnMiwgYXJnMyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIGV4cGVjdHM6IFsuLi5uZXcgU2V0KG9wdGlvbnMubWFwKChvcHRpb24pID0+IG9wdGlvbi5leHBlY3RzKSldLmpvaW4oXCIgfCBcIiksXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBsZXQgdmFsaWRSZXN1bHQ7XG4gICAgICBsZXQgdW50eXBlZFJlc3VsdHM7XG4gICAgICBsZXQgdHlwZWRSZXN1bHRzO1xuICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2YgdGhpcy5vcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICBpZiAoIXJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIHZhbGlkUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR5cGVkUmVzdWx0cyA/IHR5cGVkUmVzdWx0cy5wdXNoKHJlc3VsdCkgOiB0eXBlZFJlc3VsdHMgPSBbcmVzdWx0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW50eXBlZFJlc3VsdHMgPyB1bnR5cGVkUmVzdWx0cy5wdXNoKHJlc3VsdCkgOiB1bnR5cGVkUmVzdWx0cyA9IFtyZXN1bHRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsaWRSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHQodGhpcywgdmFsaWRSZXN1bHQub3V0cHV0LCBjb25maWcpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVkUmVzdWx0cz8ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0UmVzdWx0ID0gdHlwZWRSZXN1bHRzWzBdO1xuICAgICAgICByZXR1cm4gcGlwZVJlc3VsdChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGZpcnN0UmVzdWx0Lm91dHB1dCxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgLy8gSGludDogSWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSB0eXBlZCByZXN1bHQsIHdlIHVzZSBhIGdlbmVyYWxcbiAgICAgICAgICAvLyB1bmlvbiBpc3N1ZSB3aXRoIHN1Ymlzc3VlcyBiZWNhdXNlIHRoZSBpc3N1ZXMgY291bGQgY29udHJhZGljdFxuICAgICAgICAgIC8vIGVhY2ggb3RoZXIuXG4gICAgICAgICAgdHlwZWRSZXN1bHRzLmxlbmd0aCA9PT0gMSA/IGZpcnN0UmVzdWx0Lmlzc3VlcyA6IHNjaGVtYUlzc3VlKHRoaXMsIHVuaW9uLCBpbnB1dCwgY29uZmlnLCB7XG4gICAgICAgICAgICByZWFzb246IFwidW5pb25cIixcbiAgICAgICAgICAgIGlzc3Vlczogc3ViaXNzdWVzKHR5cGVkUmVzdWx0cylcbiAgICAgICAgICB9KS5pc3N1ZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh1bnR5cGVkUmVzdWx0cz8ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB1bnR5cGVkUmVzdWx0c1swXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCB1bmlvbiwgaW5wdXQsIGNvbmZpZywge1xuICAgICAgICBpc3N1ZXM6IHN1Ymlzc3Vlcyh1bnR5cGVkUmVzdWx0cylcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5pb24vdW5pb25Bc3luYy50c1xuZnVuY3Rpb24gdW5pb25Bc3luYyhvcHRpb25zLCBhcmcyLCBhcmczKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzIsIGFyZzMpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICBleHBlY3RzOiBbLi4ubmV3IFNldChvcHRpb25zLm1hcCgob3B0aW9uKSA9PiBvcHRpb24uZXhwZWN0cykpXS5qb2luKFwiIHwgXCIpLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIGFzeW5jIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBsZXQgdmFsaWRSZXN1bHQ7XG4gICAgICBsZXQgdW50eXBlZFJlc3VsdHM7XG4gICAgICBsZXQgdHlwZWRSZXN1bHRzO1xuICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2YgdGhpcy5vcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYS5fcGFyc2UoaW5wdXQsIGNvbmZpZyk7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICBpZiAoIXJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIHZhbGlkUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR5cGVkUmVzdWx0cyA/IHR5cGVkUmVzdWx0cy5wdXNoKHJlc3VsdCkgOiB0eXBlZFJlc3VsdHMgPSBbcmVzdWx0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW50eXBlZFJlc3VsdHMgPyB1bnR5cGVkUmVzdWx0cy5wdXNoKHJlc3VsdCkgOiB1bnR5cGVkUmVzdWx0cyA9IFtyZXN1bHRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsaWRSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyh0aGlzLCB2YWxpZFJlc3VsdC5vdXRwdXQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZWRSZXN1bHRzPy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZmlyc3RSZXN1bHQgPSB0eXBlZFJlc3VsdHNbMF07XG4gICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmMoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBmaXJzdFJlc3VsdC5vdXRwdXQsXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIC8vIEhpbnQ6IElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgdHlwZWQgcmVzdWx0LCB3ZSB1c2UgYSBnZW5lcmFsXG4gICAgICAgICAgLy8gdW5pb24gaXNzdWUgd2l0aCBzdWJpc3N1ZXMgYmVjYXVzZSB0aGUgaXNzdWVzIGNvdWxkIGNvbnRyYWRpY3RcbiAgICAgICAgICAvLyBlYWNoIG90aGVyLlxuICAgICAgICAgIHR5cGVkUmVzdWx0cy5sZW5ndGggPT09IDEgPyBmaXJzdFJlc3VsdC5pc3N1ZXMgOiBzY2hlbWFJc3N1ZSh0aGlzLCB1bmlvbkFzeW5jLCBpbnB1dCwgY29uZmlnLCB7XG4gICAgICAgICAgICByZWFzb246IFwidW5pb25cIixcbiAgICAgICAgICAgIGlzc3Vlczogc3ViaXNzdWVzKHR5cGVkUmVzdWx0cylcbiAgICAgICAgICB9KS5pc3N1ZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh1bnR5cGVkUmVzdWx0cz8ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB1bnR5cGVkUmVzdWx0c1swXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCB1bmlvbkFzeW5jLCBpbnB1dCwgY29uZmlnLCB7XG4gICAgICAgIGlzc3Vlczogc3ViaXNzdWVzKHVudHlwZWRSZXN1bHRzKVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy91bmtub3duL3Vua25vd24udHNcbmZ1bmN0aW9uIHVua25vd24ocGlwZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidW5rbm93blwiLFxuICAgIGV4cGVjdHM6IFwidW5rbm93blwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICByZXR1cm4gcGlwZVJlc3VsdCh0aGlzLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3Vua25vd24vdW5rbm93bkFzeW5jLnRzXG5mdW5jdGlvbiB1bmtub3duQXN5bmMocGlwZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidW5rbm93blwiLFxuICAgIGV4cGVjdHM6IFwidW5rbm93blwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmModGhpcywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy92YXJpYW50L3ZhcmlhbnQudHNcbmZ1bmN0aW9uIHZhcmlhbnQoa2V5LCBvcHRpb25zLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzMsIGFyZzQpO1xuICBsZXQgY2FjaGVkRXhwZWN0ZWRLZXk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ2YXJpYW50XCIsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAga2V5LFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICh0aGlzLmtleSBpbiBpbnB1dCB8fCAhY2FjaGVkRXhwZWN0ZWRLZXkpIHtcbiAgICAgICAgICBsZXQgZXhwZWN0ZWRLZXk7XG4gICAgICAgICAgbGV0IHZhcmlhbnRSZXN1bHQ7XG4gICAgICAgICAgY29uc3QgcGFyc2VPcHRpb25zID0gKG9wdGlvbnMyKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjaGVtYSBvZiBvcHRpb25zMikge1xuICAgICAgICAgICAgICBpZiAoc2NoZW1hLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlTY2hlbWEgPSBzY2hlbWEuZW50cmllc1t0aGlzLmtleV07XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5UmVzdWx0ID0ga2V5U2NoZW1hLl9wYXJzZShcbiAgICAgICAgICAgICAgICAgIGlucHV0W3RoaXMua2V5XSxcbiAgICAgICAgICAgICAgICAgIGNvbmZpZ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZWRFeHBlY3RlZEtleSkge1xuICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRLZXkgPyBleHBlY3RlZEtleS5wdXNoKGtleVNjaGVtYS5leHBlY3RzKSA6IGV4cGVjdGVkS2V5ID0gW2tleVNjaGVtYS5leHBlY3RzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFrZXlSZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBkYXRhUmVzdWx0ID0gc2NoZW1hLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgIGlmICghZGF0YVJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFudFJlc3VsdCA9IGRhdGFSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCF2YXJpYW50UmVzdWx0IHx8ICF2YXJpYW50UmVzdWx0LnR5cGVkICYmIGRhdGFSZXN1bHQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFudFJlc3VsdCA9IGRhdGFSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNjaGVtYS50eXBlID09PSBcInZhcmlhbnRcIikge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9ucyhzY2hlbWEub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhbnRSZXN1bHQgJiYgIXZhcmlhbnRSZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgIGNhY2hlZEV4cGVjdGVkS2V5ID0gY2FjaGVkRXhwZWN0ZWRLZXkgfHwgWy4uLm5ldyBTZXQoZXhwZWN0ZWRLZXkpXS5qb2luKFwiIHwgXCIpO1xuICAgICAgICAgIGlmICh2YXJpYW50UmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAodmFyaWFudFJlc3VsdC50eXBlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGlwZVJlc3VsdChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIHZhcmlhbnRSZXN1bHQub3V0cHV0LFxuICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICB2YXJpYW50UmVzdWx0Lmlzc3Vlc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhcmlhbnRSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W3RoaXMua2V5XTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIHZhcmlhbnQsIHZhbHVlMiwgY29uZmlnLCB7XG4gICAgICAgICAgZXhwZWN0ZWQ6IGNhY2hlZEV4cGVjdGVkS2V5LFxuICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCB2YXJpYW50LCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3ZhcmlhbnQvdmFyaWFudEFzeW5jLnRzXG5mdW5jdGlvbiB2YXJpYW50QXN5bmMoa2V5LCBvcHRpb25zLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFttZXNzYWdlLCBwaXBlXSA9IGRlZmF1bHRBcmdzKGFyZzMsIGFyZzQpO1xuICBsZXQgY2FjaGVkRXhwZWN0ZWRLZXk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ2YXJpYW50XCIsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBrZXksXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKHRoaXMua2V5IGluIGlucHV0IHx8ICFjYWNoZWRFeHBlY3RlZEtleSkge1xuICAgICAgICAgIGxldCBleHBlY3RlZEtleTtcbiAgICAgICAgICBsZXQgdmFyaWFudFJlc3VsdDtcbiAgICAgICAgICBjb25zdCBwYXJzZU9wdGlvbnMgPSBhc3luYyAob3B0aW9uczIpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIG9wdGlvbnMyKSB7XG4gICAgICAgICAgICAgIGlmIChzY2hlbWEudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleVNjaGVtYSA9IHNjaGVtYS5lbnRyaWVzW3RoaXMua2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlSZXN1bHQgPSBhd2FpdCBrZXlTY2hlbWEuX3BhcnNlKFxuICAgICAgICAgICAgICAgICAgaW5wdXRbdGhpcy5rZXldLFxuICAgICAgICAgICAgICAgICAgY29uZmlnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlZEV4cGVjdGVkS2V5KSB7XG4gICAgICAgICAgICAgICAgICBleHBlY3RlZEtleSA/IGV4cGVjdGVkS2V5LnB1c2goa2V5U2NoZW1hLmV4cGVjdHMpIDogZXhwZWN0ZWRLZXkgPSBba2V5U2NoZW1hLmV4cGVjdHNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWtleVJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFSZXN1bHQgPSBhd2FpdCBzY2hlbWEuX3BhcnNlKGlucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhUmVzdWx0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXJpYW50UmVzdWx0ID0gZGF0YVJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIXZhcmlhbnRSZXN1bHQgfHwgIXZhcmlhbnRSZXN1bHQudHlwZWQgJiYgZGF0YVJlc3VsdC50eXBlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJpYW50UmVzdWx0ID0gZGF0YVJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NoZW1hLnR5cGUgPT09IFwidmFyaWFudFwiKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcGFyc2VPcHRpb25zKHNjaGVtYS5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAodmFyaWFudFJlc3VsdCAmJiAhdmFyaWFudFJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgYXdhaXQgcGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgY2FjaGVkRXhwZWN0ZWRLZXkgPSBjYWNoZWRFeHBlY3RlZEtleSB8fCBbLi4ubmV3IFNldChleHBlY3RlZEtleSldLmpvaW4oXCIgfCBcIik7XG4gICAgICAgICAgaWYgKHZhcmlhbnRSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICh2YXJpYW50UmVzdWx0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwaXBlUmVzdWx0QXN5bmMoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICB2YXJpYW50UmVzdWx0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgdmFyaWFudFJlc3VsdC5pc3N1ZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YXJpYW50UmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFt0aGlzLmtleV07XG4gICAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCB2YXJpYW50QXN5bmMsIHZhbHVlMiwgY29uZmlnLCB7XG4gICAgICAgICAgZXhwZWN0ZWQ6IGNhY2hlZEV4cGVjdGVkS2V5LFxuICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFJc3N1ZSh0aGlzLCB2YXJpYW50QXN5bmMsIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdm9pZC92b2lkLnRzXG5mdW5jdGlvbiB2b2lkXyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ2b2lkXCIsXG4gICAgZXhwZWN0czogXCJ2b2lkXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIHZvaWRfLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3ZvaWQvdm9pZEFzeW5jLnRzXG5mdW5jdGlvbiB2b2lkQXN5bmMobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidm9pZFwiLFxuICAgIGV4cGVjdHM6IFwidm9pZFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0LCBjb25maWcpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFSZXN1bHQodHJ1ZSwgaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYUlzc3VlKHRoaXMsIHZvaWRBc3luYywgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9rZXlvZi9rZXlvZi50c1xuZnVuY3Rpb24ga2V5b2Yoc2NoZW1hKSB7XG4gIHJldHVybiBwaWNrbGlzdChcbiAgICBPYmplY3Qua2V5cyhzY2hlbWEuZW50cmllcylcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvbWVyZ2UvbWVyZ2UudHNcbmZ1bmN0aW9uIG1lcmdlKHNjaGVtYXMsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgY29uc3QgW3Jlc3QsIG1lc3NhZ2UsIHBpcGVdID0gcmVzdEFuZERlZmF1bHRBcmdzKGFyZzIsIGFyZzMsIGFyZzQpO1xuICByZXR1cm4gb2JqZWN0KFxuICAgIHNjaGVtYXMucmVkdWNlKFxuICAgICAgKGVudHJpZXMsIHNjaGVtYSkgPT4gKHsgLi4uZW50cmllcywgLi4uc2NoZW1hLmVudHJpZXMgfSksXG4gICAgICB7fVxuICAgICksXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGVcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvbWVyZ2UvbWVyZ2VBc3luYy50c1xuZnVuY3Rpb24gbWVyZ2VBc3luYyhzY2hlbWFzLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlLCBwaXBlXSA9IHJlc3RBbmREZWZhdWx0QXJncyhhcmcyLCBhcmczLCBhcmc0KTtcbiAgcmV0dXJuIG9iamVjdEFzeW5jKFxuICAgIHNjaGVtYXMucmVkdWNlKFxuICAgICAgKGVudHJpZXMsIHNjaGVtYSkgPT4gKHsgLi4uZW50cmllcywgLi4uc2NoZW1hLmVudHJpZXMgfSksXG4gICAgICB7fVxuICAgICksXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGVcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvb21pdC9vbWl0LnRzXG5mdW5jdGlvbiBvbWl0KHNjaGVtYSwga2V5cywgYXJnMywgYXJnNCwgYXJnNSkge1xuICBjb25zdCBbcmVzdCwgbWVzc2FnZSwgcGlwZV0gPSByZXN0QW5kRGVmYXVsdEFyZ3MoYXJnMywgYXJnNCwgYXJnNSk7XG4gIHJldHVybiBvYmplY3QoXG4gICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLmVudHJpZXMpLnJlZHVjZShcbiAgICAgIChlbnRyaWVzLCBba2V5LCBzY2hlbWEyXSkgPT4ga2V5cy5pbmNsdWRlcyhrZXkpID8gZW50cmllcyA6IHsgLi4uZW50cmllcywgW2tleV06IHNjaGVtYTIgfSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZVxuICApO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9vbWl0L29taXRBc3luYy50c1xuZnVuY3Rpb24gb21pdEFzeW5jKHNjaGVtYSwga2V5cywgYXJnMywgYXJnNCwgYXJnNSkge1xuICBjb25zdCBbcmVzdCwgbWVzc2FnZSwgcGlwZV0gPSByZXN0QW5kRGVmYXVsdEFyZ3MoYXJnMywgYXJnNCwgYXJnNSk7XG4gIHJldHVybiBvYmplY3RBc3luYyhcbiAgICBPYmplY3QuZW50cmllcyhzY2hlbWEuZW50cmllcykucmVkdWNlKFxuICAgICAgKGVudHJpZXMsIFtrZXksIHNjaGVtYTJdKSA9PiBrZXlzLmluY2x1ZGVzKGtleSkgPyBlbnRyaWVzIDogeyAuLi5lbnRyaWVzLCBba2V5XTogc2NoZW1hMiB9LFxuICAgICAge31cbiAgICApLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlXG4gICk7XG59XG5cbi8vIHNyYy9tZXRob2RzL3BhcnNlL3BhcnNlLnRzXG5mdW5jdGlvbiBwYXJzZShzY2hlbWEsIGlucHV0LCBjb25maWcpIHtcbiAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9wYXJzZShpbnB1dCwgZ2V0R2xvYmFsQ29uZmlnKGNvbmZpZykpO1xuICBpZiAocmVzdWx0Lmlzc3Vlcykge1xuICAgIHRocm93IG5ldyBWYWxpRXJyb3IocmVzdWx0Lmlzc3Vlcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5vdXRwdXQ7XG59XG5cbi8vIHNyYy9tZXRob2RzL3BhcnNlL3BhcnNlQXN5bmMudHNcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlQXN5bmMoc2NoZW1hLCBpbnB1dCwgY29uZmlnKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYS5fcGFyc2UoaW5wdXQsIGdldEdsb2JhbENvbmZpZyhjb25maWcpKTtcbiAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICB0aHJvdyBuZXcgVmFsaUVycm9yKHJlc3VsdC5pc3N1ZXMpO1xuICB9XG4gIHJldHVybiByZXN1bHQub3V0cHV0O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9wYXJ0aWFsL3BhcnRpYWwudHNcbmZ1bmN0aW9uIHBhcnRpYWwoc2NoZW1hLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlLCBwaXBlXSA9IHJlc3RBbmREZWZhdWx0QXJncyhhcmcyLCBhcmczLCBhcmc0KTtcbiAgcmV0dXJuIG9iamVjdChcbiAgICBPYmplY3QuZW50cmllcyhzY2hlbWEuZW50cmllcykucmVkdWNlKFxuICAgICAgKGVudHJpZXMsIFtrZXksIHNjaGVtYTJdKSA9PiAoe1xuICAgICAgICAuLi5lbnRyaWVzLFxuICAgICAgICBba2V5XTogb3B0aW9uYWwoc2NoZW1hMilcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlXG4gICk7XG59XG5cbi8vIHNyYy9tZXRob2RzL3BhcnRpYWwvcGFydGlhbEFzeW5jLnRzXG5mdW5jdGlvbiBwYXJ0aWFsQXN5bmMoc2NoZW1hLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlLCBwaXBlXSA9IHJlc3RBbmREZWZhdWx0QXJncyhhcmcyLCBhcmczLCBhcmc0KTtcbiAgcmV0dXJuIG9iamVjdEFzeW5jKFxuICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5lbnRyaWVzKS5yZWR1Y2UoXG4gICAgICAoZW50cmllcywgW2tleSwgc2NoZW1hMl0pID0+ICh7XG4gICAgICAgIC4uLmVudHJpZXMsXG4gICAgICAgIFtrZXldOiBvcHRpb25hbEFzeW5jKHNjaGVtYTIpXG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZVxuICApO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9waWNrL3BpY2sudHNcbmZ1bmN0aW9uIHBpY2soc2NoZW1hLCBrZXlzLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlLCBwaXBlXSA9IHJlc3RBbmREZWZhdWx0QXJncyhhcmczLCBhcmc0LCBhcmc1KTtcbiAgcmV0dXJuIG9iamVjdChcbiAgICBPYmplY3QuZW50cmllcyhzY2hlbWEuZW50cmllcykucmVkdWNlKFxuICAgICAgKGVudHJpZXMsIFtrZXksIHNjaGVtYTJdKSA9PiBrZXlzLmluY2x1ZGVzKGtleSkgPyB7IC4uLmVudHJpZXMsIFtrZXldOiBzY2hlbWEyIH0gOiBlbnRyaWVzLFxuICAgICAge31cbiAgICApLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBwaXBlXG4gICk7XG59XG5cbi8vIHNyYy9tZXRob2RzL3BpY2svcGlja0FzeW5jLnRzXG5mdW5jdGlvbiBwaWNrQXN5bmMoc2NoZW1hLCBrZXlzLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIGNvbnN0IFtyZXN0LCBtZXNzYWdlLCBwaXBlXSA9IHJlc3RBbmREZWZhdWx0QXJncyhhcmczLCBhcmc0LCBhcmc1KTtcbiAgcmV0dXJuIG9iamVjdEFzeW5jKFxuICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5lbnRyaWVzKS5yZWR1Y2UoXG4gICAgICAoZW50cmllcywgW2tleSwgc2NoZW1hMl0pID0+IGtleXMuaW5jbHVkZXMoa2V5KSA/IHsgLi4uZW50cmllcywgW2tleV06IHNjaGVtYTIgfSA6IGVudHJpZXMsXG4gICAgICB7fVxuICAgICksXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGVcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcmVxdWlyZWQvcmVxdWlyZWQudHNcbmZ1bmN0aW9uIHJlcXVpcmVkKHNjaGVtYSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICBjb25zdCBbcmVzdCwgbWVzc2FnZSwgcGlwZV0gPSByZXN0QW5kRGVmYXVsdEFyZ3MoYXJnMiwgYXJnMywgYXJnNCk7XG4gIHJldHVybiBvYmplY3QoXG4gICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLmVudHJpZXMpLnJlZHVjZShcbiAgICAgIChlbnRyaWVzLCBba2V5LCBzY2hlbWEyXSkgPT4gKHtcbiAgICAgICAgLi4uZW50cmllcyxcbiAgICAgICAgW2tleV06IG5vbk9wdGlvbmFsKHNjaGVtYTIpXG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgcGlwZVxuICApO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9yZXF1aXJlZC9yZXF1aXJlZEFzeW5jLnRzXG5mdW5jdGlvbiByZXF1aXJlZEFzeW5jKHNjaGVtYSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICBjb25zdCBbcmVzdCwgbWVzc2FnZSwgcGlwZV0gPSByZXN0QW5kRGVmYXVsdEFyZ3MoYXJnMiwgYXJnMywgYXJnNCk7XG4gIHJldHVybiBvYmplY3RBc3luYyhcbiAgICBPYmplY3QuZW50cmllcyhzY2hlbWEuZW50cmllcykucmVkdWNlKFxuICAgICAgKGVudHJpZXMsIFtrZXksIHNjaGVtYTJdKSA9PiAoe1xuICAgICAgICAuLi5lbnRyaWVzLFxuICAgICAgICBba2V5XTogbm9uT3B0aW9uYWxBc3luYyhzY2hlbWEyKVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICksXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIHBpcGVcbiAgKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvc2FmZVBhcnNlL3NhZmVQYXJzZS50c1xuZnVuY3Rpb24gc2FmZVBhcnNlKHNjaGVtYSwgaW5wdXQsIGNvbmZpZykge1xuICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3BhcnNlKGlucHV0LCBnZXRHbG9iYWxDb25maWcoY29uZmlnKSk7XG4gIHJldHVybiB7XG4gICAgdHlwZWQ6IHJlc3VsdC50eXBlZCxcbiAgICBzdWNjZXNzOiAhcmVzdWx0Lmlzc3VlcyxcbiAgICBvdXRwdXQ6IHJlc3VsdC5vdXRwdXQsXG4gICAgaXNzdWVzOiByZXN1bHQuaXNzdWVzXG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3NhZmVQYXJzZS9zYWZlUGFyc2VBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gc2FmZVBhcnNlQXN5bmMoc2NoZW1hLCBpbnB1dCwgY29uZmlnKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYS5fcGFyc2UoaW5wdXQsIGdldEdsb2JhbENvbmZpZyhjb25maWcpKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlZDogcmVzdWx0LnR5cGVkLFxuICAgIHN1Y2Nlc3M6ICFyZXN1bHQuaXNzdWVzLFxuICAgIG91dHB1dDogcmVzdWx0Lm91dHB1dCxcbiAgICBpc3N1ZXM6IHJlc3VsdC5pc3N1ZXNcbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvdHJhbnNmb3JtL3RyYW5zZm9ybS50c1xuZnVuY3Rpb24gdHJhbnNmb3JtKHNjaGVtYSwgYWN0aW9uLCBhcmcxKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIF9wYXJzZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3BhcnNlKGlucHV0LCBjb25maWcpO1xuICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgcmVzdWx0LnR5cGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQub3V0cHV0ID0gYWN0aW9uKHJlc3VsdC5vdXRwdXQsIHsgaXNzdWVzOiByZXN1bHQuaXNzdWVzIH0pO1xuICAgICAgICBpZiAoYXJnMSkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGlwZVJlc3VsdChcbiAgICAgICAgICAgICAgeyB0eXBlOiB0eXBlb2YgcmVzdWx0Lm91dHB1dCwgcGlwZTogYXJnMSB9LFxuICAgICAgICAgICAgICByZXN1bHQub3V0cHV0LFxuICAgICAgICAgICAgICBjb25maWdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcmcxLl9wYXJzZShyZXN1bHQub3V0cHV0LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvdHJhbnNmb3JtL3RyYW5zZm9ybUFzeW5jLnRzXG5mdW5jdGlvbiB0cmFuc2Zvcm1Bc3luYyhzY2hlbWEsIGFjdGlvbiwgYXJnMSkge1xuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2NoZW1hLl9wYXJzZShpbnB1dCwgY29uZmlnKTtcbiAgICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICAgIHJlc3VsdC50eXBlZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0Lm91dHB1dCA9IGF3YWl0IGFjdGlvbihyZXN1bHQub3V0cHV0LCB7IGlzc3VlczogcmVzdWx0Lmlzc3VlcyB9KTtcbiAgICAgICAgaWYgKGFyZzEpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBpcGVSZXN1bHRBc3luYyhcbiAgICAgICAgICAgICAgeyB0eXBlOiB0eXBlb2YgcmVzdWx0Lm91dHB1dCwgcGlwZTogYXJnMSB9LFxuICAgICAgICAgICAgICByZXN1bHQub3V0cHV0LFxuICAgICAgICAgICAgICBjb25maWdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcmcxLl9wYXJzZShyZXN1bHQub3V0cHV0LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvdW53cmFwL3Vud3JhcC50c1xuZnVuY3Rpb24gdW53cmFwKHNjaGVtYSkge1xuICByZXR1cm4gc2NoZW1hLndyYXBwZWQ7XG59XG5cbi8vIHNyYy9yZWdleC50c1xudmFyIEJJQ19SRUdFWCA9IC9eW0EtWl17Nn0oPyEwMClbQS1aXFxkXXsyfSg/OltBLVpcXGRdezN9KT8kL3U7XG52YXIgQ1VJRDJfUkVHRVggPSAvXlthLXpdW1xcZGEtel0qJC91O1xudmFyIERFQ0lNQUxfUkVHRVggPSAvXlxcZCskL3U7XG52YXIgRU1BSUxfUkVHRVggPSAvXltcXHcrLV0rKD86XFwuW1xcdystXSspKkBbXFxkYS16XSsoPzpbLi1dW1xcZGEtel0rKSpcXC5bYS16XXsyLH0kL2l1O1xudmFyIEVNT0pJX1JFR0VYID0gL15bXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY31cXHB7RW1vamlfQ29tcG9uZW50fV0rJC91O1xudmFyIEhFWEFERUNJTUFMX1JFR0VYID0gL14oMGh8MHgpP1tcXGRhLWZdKyQvaXU7XG52YXIgSEVYX0NPTE9SX1JFR0VYID0gL14jKFtcXGRhLWZdezN9fFtcXGRhLWZdezR9fFtcXGRhLWZdezZ9fFtcXGRhLWZdezh9KSQvaXU7XG52YXIgSU1FSV9SRUdFWCA9IC9eXFxkezJ9KD86WyAvfC1dP1xcZHs2fSl7Mn1bIC98LV0/XFxkJC91O1xudmFyIElQVjRfUkVHRVggPSAoXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWRvcy1kZXRlY3Rvci9uby11bnNhZmUtcmVnZXggLS0gZmFsc2UgcG9zaXRpdmVcbiAgL14oPzooPzpbMS05XXwxXFxkfDJbMC00XSk/XFxkfDI1WzAtNV0pKD86XFwuKD86KD86WzEtOV18MVxcZHwyWzAtNF0pP1xcZHwyNVswLTVdKSl7M30kL3Vcbik7XG52YXIgSVBWNl9SRUdFWCA9IC9eKD86KD86W1xcZGEtZl17MSw0fTopezd9W1xcZGEtZl17MSw0fXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw3fTp8KD86W1xcZGEtZl17MSw0fTopezEsNn06W1xcZGEtZl17MSw0fXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw1fSg/OjpbXFxkYS1mXXsxLDR9KXsxLDJ9fCg/OltcXGRhLWZdezEsNH06KXsxLDR9KD86OltcXGRhLWZdezEsNH0pezEsM318KD86W1xcZGEtZl17MSw0fTopezEsM30oPzo6W1xcZGEtZl17MSw0fSl7MSw0fXwoPzpbXFxkYS1mXXsxLDR9Oil7MSwyfSg/OjpbXFxkYS1mXXsxLDR9KXsxLDV9fFtcXGRhLWZdezEsNH06KD86OltcXGRhLWZdezEsNH0pezEsNn18Oig/Oig/OjpbXFxkYS1mXXsxLDR9KXsxLDd9fDopfGZlODA6KD86OltcXGRhLWZdezAsNH0pezAsNH0lW1xcZGEtel0rfDo6KD86Zns0fSg/OjowezEsNH0pPzopPyg/Oig/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpXFwuKXszfSg/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpfCg/OltcXGRhLWZdezEsNH06KXsxLDR9Oig/Oig/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpXFwuKXszfSg/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpKSQvaXU7XG52YXIgSVNPX0RBVEVfUkVHRVggPSAvXlxcZHs0fS0oPzowWzEtOV18MVswLTJdKS0oPzpbMTJdXFxkfDBbMS05XXwzWzAxXSkkL3U7XG52YXIgSVNPX0RBVEVfVElNRV9SRUdFWCA9IC9eXFxkezR9LSg/OjBbMS05XXwxWzAtMl0pLSg/OlsxMl1cXGR8MFsxLTldfDNbMDFdKVQoPzowXFxkfDFcXGR8MlswLTNdKTpbMC01XVxcZCQvdTtcbnZhciBJU09fVElNRV9SRUdFWCA9IC9eKD86MFxcZHwxXFxkfDJbMC0zXSk6WzAtNV1cXGQkL3U7XG52YXIgSVNPX1RJTUVfU0VDT05EX1JFR0VYID0gL14oPzowXFxkfDFcXGR8MlswLTNdKSg/OjpbMC01XVxcZCl7Mn0kL3U7XG52YXIgSVNPX1RJTUVTVEFNUF9SRUdFWCA9IC9eXFxkezR9LSg/OjBbMS05XXwxWzAtMl0pLSg/OlsxMl1cXGR8MFsxLTldfDNbMDFdKVQoPzowXFxkfDFcXGR8MlswLTNdKSg/OjpbMC01XVxcZCl7Mn0oPzpcXC5cXGR7MSw5fSk/WiQvdTtcbnZhciBJU09fV0VFS19SRUdFWCA9IC9eXFxkezR9LVcoPzowWzEtOV18WzEtNF1cXGR8NVswLTNdKSQvdTtcbnZhciBNQUM0OF9SRUdFWCA9IC9eKD86W1xcZGEtZl17Mn06KXs1fVtcXGRhLWZdezJ9JHxeKD86W1xcZGEtZl17Mn0tKXs1fVtcXGRhLWZdezJ9JHxeKD86W1xcZGEtZl17NH1cXC4pezJ9W1xcZGEtZl17NH0kL2l1O1xudmFyIE1BQzY0X1JFR0VYID0gL14oPzpbXFxkYS1mXXsyfTopezd9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXsyfS0pezd9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXs0fVxcLil7M31bXFxkYS1mXXs0fSR8Xig/OltcXGRhLWZdezR9Oil7M31bXFxkYS1mXXs0fSQvaXU7XG52YXIgT0NUQUxfUkVHRVggPSAvXigwbyk/WzAtN10rJC9pdTtcbnZhciBVTElEX1JFR0VYID0gL15bXFxkYS1oamttbnAtdHYtel17MjZ9JC9pdTtcbnZhciBVVUlEX1JFR0VYID0gL15bXFxkYS1mXXs4fSg/Oi1bXFxkYS1mXXs0fSl7M30tW1xcZGEtZl17MTJ9JC9pdTtcblxuLy8gc3JjL3RyYW5zZm9ybWF0aW9ucy90b0N1c3RvbS90b0N1c3RvbS50c1xuZnVuY3Rpb24gdG9DdXN0b20oYWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b19jdXN0b21cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGFjdGlvbihpbnB1dCkpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWF0aW9ucy90b0N1c3RvbS90b0N1c3RvbUFzeW5jLnRzXG5mdW5jdGlvbiB0b0N1c3RvbUFzeW5jKGFjdGlvbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9fY3VzdG9tXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgYXN5bmMgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGF3YWl0IGFjdGlvbihpbnB1dCkpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWF0aW9ucy90b0xvd2VyQ2FzZS90b0xvd2VyQ2FzZS50c1xuZnVuY3Rpb24gdG9Mb3dlckNhc2UoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b19sb3dlcl9jYXNlXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dC50b0xvY2FsZUxvd2VyQ2FzZSgpKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1hdGlvbnMvdG9NYXhWYWx1ZS90b01heFZhbHVlLnRzXG5mdW5jdGlvbiB0b01heFZhbHVlKHJlcXVpcmVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b19tYXhfdmFsdWVcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0ID4gdGhpcy5yZXF1aXJlbWVudCA/IHRoaXMucmVxdWlyZW1lbnQgOiBpbnB1dCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtYXRpb25zL3RvTWluVmFsdWUvdG9NaW5WYWx1ZS50c1xuZnVuY3Rpb24gdG9NaW5WYWx1ZShyZXF1aXJlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9fbWluX3ZhbHVlXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCA8IHRoaXMucmVxdWlyZW1lbnQgPyB0aGlzLnJlcXVpcmVtZW50IDogaW5wdXQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWF0aW9ucy90b1RyaW1tZWQvdG9UcmltbWVkLnRzXG5mdW5jdGlvbiB0b1RyaW1tZWQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b190cmltbWVkXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dC50cmltKCkpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWF0aW9ucy90b1RyaW1tZWRFbmQvdG9UcmltbWVkRW5kLnRzXG5mdW5jdGlvbiB0b1RyaW1tZWRFbmQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b190cmltbWVkX2VuZFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQudHJpbUVuZCgpKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy90cmFuc2Zvcm1hdGlvbnMvdG9UcmltbWVkU3RhcnQvdG9UcmltbWVkU3RhcnQudHNcbmZ1bmN0aW9uIHRvVHJpbW1lZFN0YXJ0KCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9fdHJpbW1lZF9zdGFydFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQudHJpbVN0YXJ0KCkpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWF0aW9ucy90b1VwcGVyQ2FzZS90b1VwcGVyQ2FzZS50c1xuZnVuY3Rpb24gdG9VcHBlckNhc2UoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b191cHBlcl9jYXNlXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dC50b1VwcGVyQ2FzZSgpKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9iaWMvYmljLnRzXG5mdW5jdGlvbiBiaWMobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYmljXCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogQklDX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgYmljLCBpbnB1dCwgXCJCSUNcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvYnl0ZXMvYnl0ZXMudHNcbmZ1bmN0aW9uIGJ5dGVzKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJieXRlc1wiLFxuICAgIGV4cGVjdHM6IGAke3JlcXVpcmVtZW50fWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBjb25zdCBsZW5ndGgyID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGlucHV0KS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoMiA9PT0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBieXRlcywgaW5wdXQsIFwiYnl0ZXNcIiwgYCR7bGVuZ3RoMn1gKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9jcmVkaXRDYXJkL2NyZWRpdENhcmQudHNcbnZhciBTQU5JVElaRV9SRUdFWCA9IC9bLSBdKy9ndTtcbnZhciBQUk9WSURFUl9SRUdFWF9MSVNUID0gW1xuICAvLyBBbWVyaWNhbiBFeHByZXNzXG4gIC9eM1s0N11cXGR7MTN9JC91LFxuICAvLyBEaW5lcnMgQ2x1YlxuICAvXjMoPzowWzAtNV18WzY4XVxcZClcXGR7MTF9JC91LFxuICAvLyBEaXNjb3ZlclxuICAvXjYoPzowMTF8NVxcZHsyfSlcXGR7MTIsMTV9JC91LFxuICAvLyBKQ0JcbiAgL14oPzoyMTMxfDE4MDB8MzVcXGR7M30pXFxkezExfSQvdSxcbiAgLy8gTWFzdGVyY2FyZFxuICAvXjVbMS01XVxcZHsyfXwoMjIyXFxkfDIyWzMtOV1cXGR8MlszLTZdXFxkezJ9fDI3WzAxXVxcZHwyNzIwKVxcZHsxMn0kL3UsXG4gIC8vIFVuaW9uUGF5XG4gIC9eKDZbMjddXFxkezE0fXw4MVxcZHsxNCwxN30pJC91LFxuICAvLyBWaXNhXG4gIC9eNFxcZHsxMn0oPzpcXGR7Myw2fSk/JC91XG5dO1xuZnVuY3Rpb24gY3JlZGl0Q2FyZChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJjcmVkaXRfY2FyZFwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IChpbnB1dCkgPT4ge1xuICAgICAgY29uc3Qgc2FuaXRpemVkID0gaW5wdXQucmVwbGFjZShTQU5JVElaRV9SRUdFWCwgXCJcIik7XG4gICAgICByZXR1cm4gUFJPVklERVJfUkVHRVhfTElTVC5zb21lKChyZWdleDIpID0+IHJlZ2V4Mi50ZXN0KHNhbml0aXplZCkpICYmIGlzTHVobkFsZ28oc2FuaXRpemVkKTtcbiAgICB9LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIGNyZWRpdENhcmQsIGlucHV0LCBcImNyZWRpdCBjYXJkXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2N1aWQyL2N1aWQyLnRzXG5mdW5jdGlvbiBjdWlkMihtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJjdWlkMlwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IENVSUQyX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgY3VpZDIsIGlucHV0LCBcIkN1aWQyXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2N1c3RvbS9jdXN0b20udHNcbmZ1bmN0aW9uIGN1c3RvbShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiY3VzdG9tXCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVpcmVtZW50KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBjdXN0b20sIGlucHV0LCBcImlucHV0XCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2N1c3RvbS9jdXN0b21Bc3luYy50c1xuZnVuY3Rpb24gY3VzdG9tQXN5bmMocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImN1c3RvbVwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBhc3luYyBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmIChhd2FpdCB0aGlzLnJlcXVpcmVtZW50KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBjdXN0b21Bc3luYywgaW5wdXQsIFwiaW5wdXRcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvZGVjaW1hbC9kZWNpbWFsLnRzXG5mdW5jdGlvbiBkZWNpbWFsKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImRlY2ltYWxcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBERUNJTUFMX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgZGVjaW1hbCwgaW5wdXQsIFwiZGVjaW1hbFwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9lbWFpbC9lbWFpbC50c1xuZnVuY3Rpb24gZW1haWwobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZW1haWxcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBFTUFJTF9SRUdFWCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVpcmVtZW50LnRlc3QoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIGVtYWlsLCBpbnB1dCwgXCJlbWFpbFwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9lbW9qaS9lbW9qaS50c1xuZnVuY3Rpb24gZW1vamkobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZW1vamlcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBFTU9KSV9SRUdFWCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVpcmVtZW50LnRlc3QoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIGVtb2ppLCBpbnB1dCwgXCJlbW9qaVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9lbmRzV2l0aC9lbmRzV2l0aC50c1xuZnVuY3Rpb24gZW5kc1dpdGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVuZHNfd2l0aFwiLFxuICAgIGV4cGVjdHM6IGBcIiR7cmVxdWlyZW1lbnR9XCJgLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKGlucHV0LmVuZHNXaXRoKHRoaXMucmVxdWlyZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKFxuICAgICAgICB0aGlzLFxuICAgICAgICBlbmRzV2l0aCxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIFwiZW5kXCIsXG4gICAgICAgIGBcIiR7aW5wdXQuc2xpY2UoLXRoaXMucmVxdWlyZW1lbnQubGVuZ3RoKX1cImBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvZXZlcnkvZXZlcnkudHNcbmZ1bmN0aW9uIGV2ZXJ5KHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJldmVyeVwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuZXZlcnkodGhpcy5yZXF1aXJlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgZXZlcnksIGlucHV0LCBcImlucHV0XCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2V4Y2x1ZGVzL2V4Y2x1ZGVzLnRzXG5mdW5jdGlvbiBleGNsdWRlcyhyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICBjb25zdCByZWNlaXZlZCA9IHN0cmluZ2lmeShyZXF1aXJlbWVudCk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJleGNsdWRlc1wiLFxuICAgIGV4cGVjdHM6IGAhJHtyZWNlaXZlZH1gLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKCFpbnB1dC5pbmNsdWRlcyh0aGlzLnJlcXVpcmVtZW50KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBleGNsdWRlcywgaW5wdXQsIFwiY29udGVudFwiLCByZWNlaXZlZCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvZmluaXRlL2Zpbml0ZS50c1xuZnVuY3Rpb24gZmluaXRlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImZpbml0ZVwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IE51bWJlci5pc0Zpbml0ZSxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVpcmVtZW50KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBmaW5pdGUsIGlucHV0LCBcImZpbml0ZVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9oYXNoL2hhc2gudHNcbnZhciBIQVNIX0xFTkdUSFMgPSB7XG4gIG1kNDogMzIsXG4gIG1kNTogMzIsXG4gIHNoYTE6IDQwLFxuICBzaGEyNTY6IDY0LFxuICBzaGEzODQ6IDk2LFxuICBzaGE1MTI6IDEyOCxcbiAgcmlwZW1kMTI4OiAzMixcbiAgcmlwZW1kMTYwOiA0MCxcbiAgdGlnZXIxMjg6IDMyLFxuICB0aWdlcjE2MDogNDAsXG4gIHRpZ2VyMTkyOiA0OCxcbiAgY3JjMzI6IDgsXG4gIGNyYzMyYjogOCxcbiAgYWRsZXIzMjogOFxufTtcbmZ1bmN0aW9uIGhhc2godHlwZXMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImhhc2hcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBSZWdFeHAoXG4gICAgICB0eXBlcy5tYXAoKHR5cGUpID0+IGBeW2EtZjAtOV17JHtIQVNIX0xFTkdUSFNbdHlwZV19fSRgKS5qb2luKFwifFwiKSxcbiAgICAgIFwiaXVcIlxuICAgICksXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBoYXNoLCBpbnB1dCwgXCJoYXNoXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2hleGFkZWNpbWFsL2hleGFkZWNpbWFsLnRzXG5mdW5jdGlvbiBoZXhhZGVjaW1hbChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJoZXhhZGVjaW1hbFwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IEhFWEFERUNJTUFMX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgaGV4YWRlY2ltYWwsIGlucHV0LCBcImhleGFkZWNpbWFsXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2hleENvbG9yL2hleENvbG9yLnRzXG5mdW5jdGlvbiBoZXhDb2xvcihtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJoZXhfY29sb3JcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBIRVhfQ09MT1JfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBoZXhDb2xvciwgaW5wdXQsIFwiaGV4IGNvbG9yXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2ltZWkvaW1laS50c1xuZnVuY3Rpb24gaW1laShtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJpbWVpXCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogW0lNRUlfUkVHRVgsIGlzTHVobkFsZ29dLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnRbMF0udGVzdChpbnB1dCkgJiYgdGhpcy5yZXF1aXJlbWVudFsxXShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgaW1laSwgaW5wdXQsIFwiSU1FSVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9pbmNsdWRlcy9pbmNsdWRlcy50c1xuZnVuY3Rpb24gaW5jbHVkZXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgY29uc3QgZXhwZWN0cyA9IHN0cmluZ2lmeShyZXF1aXJlbWVudCk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJpbmNsdWRlc1wiLFxuICAgIGV4cGVjdHMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuaW5jbHVkZXModGhpcy5yZXF1aXJlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgaW5jbHVkZXMsIGlucHV0LCBcImNvbnRlbnRcIiwgYCEke2V4cGVjdHN9YCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaW50ZWdlci9pbnRlZ2VyLnRzXG5mdW5jdGlvbiBpbnRlZ2VyKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImludGVnZXJcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBOdW1iZXIuaXNJbnRlZ2VyLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIGludGVnZXIsIGlucHV0LCBcImludGVnZXJcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaXAvaXAudHNcbmZ1bmN0aW9uIGlwKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImlwXCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICAvLyBUT0RPOiBJdCBpcyBzdHJhbmdlIHRoYXQgd2UgaGF2ZSBhbiBPUiByZWxhdGlvbnNoaXAgYmV0d2VlbiByZXF1aXJlbWVudHNcbiAgICByZXF1aXJlbWVudDogW0lQVjRfUkVHRVgsIElQVjZfUkVHRVhdLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnRbMF0udGVzdChpbnB1dCkgfHwgdGhpcy5yZXF1aXJlbWVudFsxXS50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBpcCwgaW5wdXQsIFwiSVBcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaXB2NC9pcHY0LnRzXG5mdW5jdGlvbiBpcHY0KG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImlwdjRcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBJUFY0X1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgaXB2NCwgaW5wdXQsIFwiSVB2NFwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9pcHY2L2lwdjYudHNcbmZ1bmN0aW9uIGlwdjYobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaXB2NlwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IElQVjZfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBpcHY2LCBpbnB1dCwgXCJJUHY2XCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2lzb0RhdGUvaXNvRGF0ZS50c1xuZnVuY3Rpb24gaXNvRGF0ZShtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJpc29fZGF0ZVwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IElTT19EQVRFX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgaXNvRGF0ZSwgaW5wdXQsIFwiZGF0ZVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9pc29EYXRlVGltZS9pc29EYXRlVGltZS50c1xuZnVuY3Rpb24gaXNvRGF0ZVRpbWUobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaXNvX2RhdGVfdGltZVwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IElTT19EQVRFX1RJTUVfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBpc29EYXRlVGltZSwgaW5wdXQsIFwiZGF0ZS10aW1lXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2lzb1RpbWUvaXNvVGltZS50c1xuZnVuY3Rpb24gaXNvVGltZShtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJpc29fdGltZVwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IElTT19USU1FX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgaXNvVGltZSwgaW5wdXQsIFwidGltZVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9pc29UaW1lU2Vjb25kL2lzb1RpbWVTZWNvbmQudHNcbmZ1bmN0aW9uIGlzb1RpbWVTZWNvbmQobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaXNvX3RpbWVfc2Vjb25kXCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogSVNPX1RJTUVfU0VDT05EX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgaXNvVGltZVNlY29uZCwgaW5wdXQsIFwidGltZSBzZWNvbmRcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaXNvVGltZXN0YW1wL2lzb1RpbWVzdGFtcC50c1xuZnVuY3Rpb24gaXNvVGltZXN0YW1wKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImlzb190aW1lc3RhbXBcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBJU09fVElNRVNUQU1QX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgaXNvVGltZXN0YW1wLCBpbnB1dCwgXCJ0aW1lc3RhbXBcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvaXNvV2Vlay9pc29XZWVrLnRzXG5mdW5jdGlvbiBpc29XZWVrKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImlzb193ZWVrXCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogSVNPX1dFRUtfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBpc29XZWVrLCBpbnB1dCwgXCJ3ZWVrXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL2xlbmd0aC9sZW5ndGgudHNcbmZ1bmN0aW9uIGxlbmd0aChyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibGVuZ3RoXCIsXG4gICAgZXhwZWN0czogYCR7cmVxdWlyZW1lbnR9YCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGggPT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgbGVuZ3RoLCBpbnB1dCwgXCJsZW5ndGhcIiwgYCR7aW5wdXQubGVuZ3RofWApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL21hYy9tYWMudHNcbmZ1bmN0aW9uIG1hYyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJtYWNcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIC8vIFRPRE86IEl0IGlzIHN0cmFuZ2UgdGhhdCB3ZSBoYXZlIGFuIE9SIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHJlcXVpcmVtZW50c1xuICAgIHJlcXVpcmVtZW50OiBbTUFDNDhfUkVHRVgsIE1BQzY0X1JFR0VYXSxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVpcmVtZW50WzBdLnRlc3QoaW5wdXQpIHx8IHRoaXMucmVxdWlyZW1lbnRbMV0udGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgbWFjLCBpbnB1dCwgXCJNQUNcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvbWFjNDgvbWFjNDgudHNcbmZ1bmN0aW9uIG1hYzQ4KG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1hYzQ4XCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogTUFDNDhfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBtYWM0OCwgaW5wdXQsIFwiNDgtYml0IE1BQ1wiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9tYWM2NC9tYWM2NC50c1xuZnVuY3Rpb24gbWFjNjQobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibWFjNjRcIixcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50OiBNQUM2NF9SRUdFWCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVpcmVtZW50LnRlc3QoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIG1hYzY0LCBpbnB1dCwgXCI2NC1iaXQgTUFDXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL21heEJ5dGVzL21heEJ5dGVzLnRzXG5mdW5jdGlvbiBtYXhCeXRlcyhyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibWF4X2J5dGVzXCIsXG4gICAgZXhwZWN0czogYDw9JHtyZXF1aXJlbWVudH1gLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgY29uc3QgbGVuZ3RoMiA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShpbnB1dCkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aDIgPD0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBtYXhCeXRlcywgaW5wdXQsIFwiYnl0ZXNcIiwgYCR7bGVuZ3RoMn1gKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9tYXhMZW5ndGgvbWF4TGVuZ3RoLnRzXG5mdW5jdGlvbiBtYXhMZW5ndGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1heF9sZW5ndGhcIixcbiAgICBleHBlY3RzOiBgPD0ke3JlcXVpcmVtZW50fWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgbWF4TGVuZ3RoLCBpbnB1dCwgXCJsZW5ndGhcIiwgYCR7aW5wdXQubGVuZ3RofWApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL21heFNpemUvbWF4U2l6ZS50c1xuZnVuY3Rpb24gbWF4U2l6ZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibWF4X3NpemVcIixcbiAgICBleHBlY3RzOiBgPD0ke3JlcXVpcmVtZW50fWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuc2l6ZSA8PSB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIG1heFNpemUsIGlucHV0LCBcInNpemVcIiwgYCR7aW5wdXQuc2l6ZX1gKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9tYXhWYWx1ZS9tYXhWYWx1ZS50c1xuZnVuY3Rpb24gbWF4VmFsdWUocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1heF92YWx1ZVwiLFxuICAgIGV4cGVjdHM6IGA8PSR7cmVxdWlyZW1lbnQgaW5zdGFuY2VvZiBEYXRlID8gcmVxdWlyZW1lbnQudG9KU09OKCkgOiBzdHJpbmdpZnkocmVxdWlyZW1lbnQpfWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgPD0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbWF4VmFsdWUsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBcInZhbHVlXCIsXG4gICAgICAgIGlucHV0IGluc3RhbmNlb2YgRGF0ZSA/IGlucHV0LnRvSlNPTigpIDogc3RyaW5naWZ5KGlucHV0KVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9taW5CeXRlcy9taW5CeXRlcy50c1xuZnVuY3Rpb24gbWluQnl0ZXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1pbl9ieXRlc1wiLFxuICAgIGV4cGVjdHM6IGA+PSR7cmVxdWlyZW1lbnR9YCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGNvbnN0IGxlbmd0aDIgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoaW5wdXQpLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgyID49IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgbWluQnl0ZXMsIGlucHV0LCBcImJ5dGVzXCIsIGAke2xlbmd0aDJ9YCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvbWltZVR5cGUvbWltZVR5cGUudHNcbmZ1bmN0aW9uIG1pbWVUeXBlKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJtaW1lX3R5cGVcIixcbiAgICBleHBlY3RzOiByZXF1aXJlbWVudC5tYXAoKG9wdGlvbikgPT4gYFwiJHtvcHRpb259XCJgKS5qb2luKFwiIHwgXCIpLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQuaW5jbHVkZXMoaW5wdXQudHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgbWltZVR5cGUsIGlucHV0LCBcIk1JTUUgdHlwZVwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9taW5MZW5ndGgvbWluTGVuZ3RoLnRzXG5mdW5jdGlvbiBtaW5MZW5ndGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1pbl9sZW5ndGhcIixcbiAgICBleHBlY3RzOiBgPj0ke3JlcXVpcmVtZW50fWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID49IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgbWluTGVuZ3RoLCBpbnB1dCwgXCJsZW5ndGhcIiwgYCR7aW5wdXQubGVuZ3RofWApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL21pblNpemUvbWluU2l6ZS50c1xuZnVuY3Rpb24gbWluU2l6ZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibWluX3NpemVcIixcbiAgICBleHBlY3RzOiBgPj0ke3JlcXVpcmVtZW50fWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuc2l6ZSA+PSB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIG1pblNpemUsIGlucHV0LCBcInNpemVcIiwgYCR7aW5wdXQuc2l6ZX1gKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9taW5WYWx1ZS9taW5WYWx1ZS50c1xuZnVuY3Rpb24gbWluVmFsdWUocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm1pbl92YWx1ZVwiLFxuICAgIGV4cGVjdHM6IGA+PSR7cmVxdWlyZW1lbnQgaW5zdGFuY2VvZiBEYXRlID8gcmVxdWlyZW1lbnQudG9KU09OKCkgOiBzdHJpbmdpZnkocmVxdWlyZW1lbnQpfWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgPj0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbWluVmFsdWUsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBcInZhbHVlXCIsXG4gICAgICAgIGlucHV0IGluc3RhbmNlb2YgRGF0ZSA/IGlucHV0LnRvSlNPTigpIDogc3RyaW5naWZ5KGlucHV0KVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9tdWx0aXBsZU9mL211bHRpcGxlT2YudHNcbmZ1bmN0aW9uIG11bHRpcGxlT2YocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm11bHRpcGxlX29mXCIsXG4gICAgZXhwZWN0czogYCUke3JlcXVpcmVtZW50fWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgJSB0aGlzLnJlcXVpcmVtZW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIG11bHRpcGxlT2YsIGlucHV0LCBcIm11bHRpcGxlXCIsIGAke2lucHV0fWApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL25vdEJ5dGVzL25vdEJ5dGVzLnRzXG5mdW5jdGlvbiBub3RCeXRlcyhyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibm90X2J5dGVzXCIsXG4gICAgZXhwZWN0czogYCEke3JlcXVpcmVtZW50fWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBjb25zdCBsZW5ndGgyID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGlucHV0KS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoMiAhPT0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBub3RCeXRlcywgaW5wdXQsIFwiYnl0ZXNcIiwgYCR7bGVuZ3RoMn1gKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9ub3RMZW5ndGgvbm90TGVuZ3RoLnRzXG5mdW5jdGlvbiBub3RMZW5ndGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm5vdF9sZW5ndGhcIixcbiAgICBleHBlY3RzOiBgISR7cmVxdWlyZW1lbnR9YCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGggIT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgbm90TGVuZ3RoLCBpbnB1dCwgXCJsZW5ndGhcIiwgYCR7aW5wdXQubGVuZ3RofWApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL25vdFNpemUvbm90U2l6ZS50c1xuZnVuY3Rpb24gbm90U2l6ZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibm90X3NpemVcIixcbiAgICBleHBlY3RzOiBgISR7cmVxdWlyZW1lbnR9YCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dC5zaXplICE9PSB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIG5vdFNpemUsIGlucHV0LCBcInNpemVcIiwgYCR7aW5wdXQuc2l6ZX1gKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9ub3RWYWx1ZS9ub3RWYWx1ZS50c1xuZnVuY3Rpb24gbm90VmFsdWUocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm5vdF92YWx1ZVwiLFxuICAgIGV4cGVjdHM6IGAhJHtyZXF1aXJlbWVudCBpbnN0YW5jZW9mIERhdGUgPyByZXF1aXJlbWVudC50b0pTT04oKSA6IHN0cmluZ2lmeShyZXF1aXJlbWVudCl9YCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCA8IHRoaXMucmVxdWlyZW1lbnQgfHwgaW5wdXQgPiB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKFxuICAgICAgICB0aGlzLFxuICAgICAgICBub3RWYWx1ZSxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIFwidmFsdWVcIixcbiAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBEYXRlID8gaW5wdXQudG9KU09OKCkgOiBzdHJpbmdpZnkoaW5wdXQpXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL29jdGFsL29jdGFsLnRzXG5mdW5jdGlvbiBvY3RhbChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJvY3RhbFwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IE9DVEFMX1JFR0VYLFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgb2N0YWwsIGlucHV0LCBcIm9jdGFsXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL3JlZ2V4L3JlZ2V4LnRzXG5mdW5jdGlvbiByZWdleChyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicmVnZXhcIixcbiAgICBleHBlY3RzOiBgJHtyZXF1aXJlbWVudH1gLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKHRoaXMucmVxdWlyZW1lbnQudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgcmVnZXgsIGlucHV0LCBcImZvcm1hdFwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9zYWZlSW50ZWdlci9zYWZlSW50ZWdlci50c1xuZnVuY3Rpb24gc2FmZUludGVnZXIobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic2FmZV9pbnRlZ2VyXCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogTnVtYmVyLmlzU2FmZUludGVnZXIsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5yZXF1aXJlbWVudChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgc2FmZUludGVnZXIsIGlucHV0LCBcInNhZmUgaW50ZWdlclwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9zaXplL3NpemUudHNcbmZ1bmN0aW9uIHNpemUocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNpemVcIixcbiAgICBleHBlY3RzOiBgJHtyZXF1aXJlbWVudH1gLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgaWYgKGlucHV0LnNpemUgPT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUodGhpcywgc2l6ZSwgaW5wdXQsIFwic2l6ZVwiLCBgJHtpbnB1dC5zaXplfWApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL3NvbWUvc29tZS50c1xuZnVuY3Rpb24gc29tZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic29tZVwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuc29tZSh0aGlzLnJlcXVpcmVtZW50KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCBzb21lLCBpbnB1dCwgXCJpbnB1dFwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy9zdGFydHNXaXRoL3N0YXJ0c1dpdGgudHNcbmZ1bmN0aW9uIHN0YXJ0c1dpdGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN0YXJ0c193aXRoXCIsXG4gICAgZXhwZWN0czogYFwiJHtyZXF1aXJlbWVudH1cImAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuc3RhcnRzV2l0aCh0aGlzLnJlcXVpcmVtZW50KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgc3RhcnRzV2l0aCxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIFwic3RhcnRcIixcbiAgICAgICAgYFwiJHtpbnB1dC5zbGljZSgwLCB0aGlzLnJlcXVpcmVtZW50Lmxlbmd0aCl9XCJgXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL3VsaWQvdWxpZC50c1xuZnVuY3Rpb24gdWxpZChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ1bGlkXCIsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudDogVUxJRF9SRUdFWCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVpcmVtZW50LnRlc3QoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25PdXRwdXQoaW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvbklzc3VlKHRoaXMsIHVsaWQsIGlucHV0LCBcIlVMSURcIik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdmFsaWRhdGlvbnMvdXJsL3VybC50c1xuZnVuY3Rpb24gdXJsKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInVybFwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQoaW5wdXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBVUkwoaW5wdXQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVpcmVtZW50KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCB1cmwsIGlucHV0LCBcIlVSTFwiKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy92YWxpZGF0aW9ucy91dWlkL3V1aWQudHNcbmZ1bmN0aW9uIHV1aWQobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidXVpZFwiLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgcmVxdWlyZW1lbnQ6IFVVSURfUkVHRVgsXG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5yZXF1aXJlbWVudC50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uT3V0cHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25Jc3N1ZSh0aGlzLCB1dWlkLCBpbnB1dCwgXCJVVUlEXCIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRpb25zL3ZhbHVlL3ZhbHVlLnRzXG5mdW5jdGlvbiB2YWx1ZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidmFsdWVcIixcbiAgICBleHBlY3RzOiBgJHtyZXF1aXJlbWVudCBpbnN0YW5jZW9mIERhdGUgPyByZXF1aXJlbWVudC50b0pTT04oKSA6IHN0cmluZ2lmeShyZXF1aXJlbWVudCl9YCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCA8PSB0aGlzLnJlcXVpcmVtZW50ICYmIGlucHV0ID49IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbk91dHB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uSXNzdWUoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgXCJ2YWx1ZVwiLFxuICAgICAgICBpbnB1dCBpbnN0YW5jZW9mIERhdGUgPyBpbnB1dC50b0pTT04oKSA6IHN0cmluZ2lmeShpbnB1dClcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuZXhwb3J0IHtcbiAgQklDX1JFR0VYLFxuICBCcmFuZFN5bWJvbCxcbiAgQ1VJRDJfUkVHRVgsXG4gIERFQ0lNQUxfUkVHRVgsXG4gIEVNQUlMX1JFR0VYLFxuICBFTU9KSV9SRUdFWCxcbiAgSEVYQURFQ0lNQUxfUkVHRVgsXG4gIEhFWF9DT0xPUl9SRUdFWCxcbiAgSU1FSV9SRUdFWCxcbiAgSVBWNF9SRUdFWCxcbiAgSVBWNl9SRUdFWCxcbiAgSVNPX0RBVEVfUkVHRVgsXG4gIElTT19EQVRFX1RJTUVfUkVHRVgsXG4gIElTT19USU1FU1RBTVBfUkVHRVgsXG4gIElTT19USU1FX1JFR0VYLFxuICBJU09fVElNRV9TRUNPTkRfUkVHRVgsXG4gIElTT19XRUVLX1JFR0VYLFxuICBNQUM0OF9SRUdFWCxcbiAgTUFDNjRfUkVHRVgsXG4gIE9DVEFMX1JFR0VYLFxuICBVTElEX1JFR0VYLFxuICBVVUlEX1JFR0VYLFxuICBWYWxpRXJyb3IsXG4gIGFjdGlvbklzc3VlLFxuICBhY3Rpb25PdXRwdXQsXG4gIGFueSxcbiAgYW55QXN5bmMsXG4gIGFycmF5LFxuICBhcnJheUFzeW5jLFxuICBiaWMsXG4gIGJpZ2ludCxcbiAgYmlnaW50QXN5bmMsXG4gIGJsb2IsXG4gIGJsb2JBc3luYyxcbiAgYm9vbGVhbixcbiAgYm9vbGVhbkFzeW5jLFxuICBicmFuZCxcbiAgYnl0ZXMsXG4gIGNvZXJjZSxcbiAgY29lcmNlQXN5bmMsXG4gIGNyZWRpdENhcmQsXG4gIGN1aWQyLFxuICBjdXN0b20sXG4gIGN1c3RvbUFzeW5jLFxuICBkYXRlLFxuICBkYXRlQXN5bmMsXG4gIGRlY2ltYWwsXG4gIGRlZmF1bHRBcmdzLFxuICBkZWxldGVHbG9iYWxDb25maWcsXG4gIGRlbGV0ZUdsb2JhbE1lc3NhZ2UsXG4gIGRlbGV0ZVNjaGVtYU1lc3NhZ2UsXG4gIGRlbGV0ZVNwZWNpZmljTWVzc2FnZSxcbiAgZW1haWwsXG4gIGVtb2ppLFxuICBlbmRzV2l0aCxcbiAgZW51bUFzeW5jLFxuICBlbnVtXyxcbiAgZXZlcnksXG4gIGV4Y2x1ZGVzLFxuICBmYWxsYmFjayxcbiAgZmFsbGJhY2tBc3luYyxcbiAgZmluaXRlLFxuICBmbGF0dGVuLFxuICBmb3J3YXJkLFxuICBmb3J3YXJkQXN5bmMsXG4gIGdldERlZmF1bHQsXG4gIGdldERlZmF1bHRBc3luYyxcbiAgZ2V0RGVmYXVsdHMsXG4gIGdldERlZmF1bHRzQXN5bmMsXG4gIGdldEZhbGxiYWNrLFxuICBnZXRGYWxsYmFja0FzeW5jLFxuICBnZXRGYWxsYmFja3MsXG4gIGdldEZhbGxiYWNrc0FzeW5jLFxuICBnZXRHbG9iYWxDb25maWcsXG4gIGdldEdsb2JhbE1lc3NhZ2UsXG4gIGdldFNjaGVtYU1lc3NhZ2UsXG4gIGdldFNwZWNpZmljTWVzc2FnZSxcbiAgaGFzaCxcbiAgaGV4Q29sb3IsXG4gIGhleGFkZWNpbWFsLFxuICBpMThuLFxuICBpbWVpLFxuICBpbmNsdWRlcyxcbiAgaW5zdGFuY2UsXG4gIGluc3RhbmNlQXN5bmMsXG4gIGludGVnZXIsXG4gIGludGVyc2VjdCxcbiAgaW50ZXJzZWN0QXN5bmMsXG4gIGlwLFxuICBpcHY0LFxuICBpcHY2LFxuICBpcyxcbiAgaXNMdWhuQWxnbyxcbiAgaXNPZlR5cGUsXG4gIGlzb0RhdGUsXG4gIGlzb0RhdGVUaW1lLFxuICBpc29UaW1lLFxuICBpc29UaW1lU2Vjb25kLFxuICBpc29UaW1lc3RhbXAsXG4gIGlzb1dlZWssXG4gIGtleW9mLFxuICBsYXp5LFxuICBsYXp5QXN5bmMsXG4gIGxlbmd0aCxcbiAgbGl0ZXJhbCxcbiAgbGl0ZXJhbEFzeW5jLFxuICBtYWMsXG4gIG1hYzQ4LFxuICBtYWM2NCxcbiAgbWFwLFxuICBtYXBBc3luYyxcbiAgbWF4Qnl0ZXMsXG4gIG1heExlbmd0aCxcbiAgbWF4U2l6ZSxcbiAgbWF4VmFsdWUsXG4gIG1lcmdlLFxuICBtZXJnZUFzeW5jLFxuICBtaW1lVHlwZSxcbiAgbWluQnl0ZXMsXG4gIG1pbkxlbmd0aCxcbiAgbWluU2l6ZSxcbiAgbWluVmFsdWUsXG4gIG11bHRpcGxlT2YsXG4gIG5hbixcbiAgbmFuQXN5bmMsXG4gIG5ldmVyLFxuICBuZXZlckFzeW5jLFxuICBub25OdWxsYWJsZSxcbiAgbm9uTnVsbGFibGVBc3luYyxcbiAgbm9uTnVsbGlzaCxcbiAgbm9uTnVsbGlzaEFzeW5jLFxuICBub25PcHRpb25hbCxcbiAgbm9uT3B0aW9uYWxBc3luYyxcbiAgbm90Qnl0ZXMsXG4gIG5vdExlbmd0aCxcbiAgbm90U2l6ZSxcbiAgbm90VmFsdWUsXG4gIG51bGxBc3luYyxcbiAgbnVsbF8sXG4gIG51bGxhYmxlLFxuICBudWxsYWJsZUFzeW5jLFxuICBudWxsaXNoLFxuICBudWxsaXNoQXN5bmMsXG4gIG51bWJlcixcbiAgbnVtYmVyQXN5bmMsXG4gIG9iamVjdCxcbiAgb2JqZWN0QXN5bmMsXG4gIG9jdGFsLFxuICBvbWl0LFxuICBvbWl0QXN5bmMsXG4gIG9wdGlvbmFsLFxuICBvcHRpb25hbEFzeW5jLFxuICBwYXJzZSxcbiAgcGFyc2VBc3luYyxcbiAgcGFydGlhbCxcbiAgcGFydGlhbEFzeW5jLFxuICBwaWNrLFxuICBwaWNrQXN5bmMsXG4gIHBpY2tsaXN0LFxuICBwaWNrbGlzdEFzeW5jLFxuICBwaXBlUmVzdWx0LFxuICBwaXBlUmVzdWx0QXN5bmMsXG4gIHJlY29yZCxcbiAgcmVjb3JkQXN5bmMsXG4gIHJlZ2V4LFxuICByZXF1aXJlZCxcbiAgcmVxdWlyZWRBc3luYyxcbiAgcmVzdEFuZERlZmF1bHRBcmdzLFxuICBzYWZlSW50ZWdlcixcbiAgc2FmZVBhcnNlLFxuICBzYWZlUGFyc2VBc3luYyxcbiAgc2NoZW1hSXNzdWUsXG4gIHNjaGVtYVJlc3VsdCxcbiAgc2V0LFxuICBzZXRBc3luYyxcbiAgc2V0R2xvYmFsQ29uZmlnLFxuICBzZXRHbG9iYWxNZXNzYWdlLFxuICBzZXRTY2hlbWFNZXNzYWdlLFxuICBzZXRTcGVjaWZpY01lc3NhZ2UsXG4gIHNpemUsXG4gIHNvbWUsXG4gIHNwZWNpYWwsXG4gIHNwZWNpYWxBc3luYyxcbiAgc3RhcnRzV2l0aCxcbiAgc3RyaW5nLFxuICBzdHJpbmdBc3luYyxcbiAgc3RyaW5naWZ5LFxuICBzeW1ib2wsXG4gIHN5bWJvbEFzeW5jLFxuICB0b0N1c3RvbSxcbiAgdG9DdXN0b21Bc3luYyxcbiAgdG9Mb3dlckNhc2UsXG4gIHRvTWF4VmFsdWUsXG4gIHRvTWluVmFsdWUsXG4gIHRvVHJpbW1lZCxcbiAgdG9UcmltbWVkRW5kLFxuICB0b1RyaW1tZWRTdGFydCxcbiAgdG9VcHBlckNhc2UsXG4gIHRyYW5zZm9ybSxcbiAgdHJhbnNmb3JtQXN5bmMsXG4gIHR1cGxlLFxuICB0dXBsZUFzeW5jLFxuICB1bGlkLFxuICB1bmRlZmluZWRBc3luYyxcbiAgdW5kZWZpbmVkXyxcbiAgdW5pb24sXG4gIHVuaW9uQXN5bmMsXG4gIHVua25vd24sXG4gIHVua25vd25Bc3luYyxcbiAgdW53cmFwLFxuICB1cmwsXG4gIHV1aWQsXG4gIHZhbHVlLFxuICB2YXJpYW50LFxuICB2YXJpYW50QXN5bmMsXG4gIHZvaWRBc3luYyxcbiAgdm9pZF9cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/valibot/dist/index.js\n");

/***/ })

};
;